{
  "examples": [
    { "complexity": "O(1)", "code": "def is_even(n):\n    return n % 2 == 0" },
    { "complexity": "O(1)", "code": "def get_first_element(arr):\n    return arr[0]" },
    { "complexity": "O(1)", "code": "def get_last_element(arr):\n    return arr[-1]" },
    { "complexity": "O(1)", "code": "def add_one(x):\n    return x + 1" },
    { "complexity": "O(1)", "code": "def multiply_by_two(x):\n    return x * 2" },
    { "complexity": "O(1)", "code": "def is_none(x):\n    return x is None" },
    { "complexity": "O(1)", "code": "def negate(b):\n    return not b" },
    { "complexity": "O(1)", "code": "def get_abs(x):\n    return abs(x)" },
    { "complexity": "O(1)", "code": "def swap(a, b):\n    return b, a" },
    { "complexity": "O(1)", "code": "def is_positive(n):\n    return n > 0" },
    { "complexity": "O(1)", "code": "def get_remainder(a, b):\n    return a % b" },
    { "complexity": "O(1)", "code": "def get_pi():\n    return 3.141592653589793" },
    { "complexity": "O(1)", "code": "def bool_to_int(b):\n    return int(b)" },
    { "complexity": "O(1)", "code": "def is_vowel(c):\n    return c.lower() in 'aeiou'" },
    { "complexity": "O(1)", "code": "def dict_has_key(d, k):\n    return k in d" },
    { "complexity": "O(1)", "code": "def add_to_set(s, e):\n    s.add(e)\n    return s" },
    { "complexity": "O(1)", "code": "def get_identity(x):\n    return x" },
    { "complexity": "O(1)", "code": "def is_zero(x):\n    return x == 0" },
    { "complexity": "O(1)", "code": "def get_len_one_tuple(x):\n    return (x,)" },
    { "complexity": "O(1)", "code": "def upper_first_char(s):\n    return s[0].upper() + s[1:] if s else s" },
    { "complexity": "O(1)", "code": "def always_true():\n    return True" },
    { "complexity": "O(1)", "code": "def always_false():\n    return False" },
    { "complexity": "O(1)", "code": "def empty_list():\n    return []" },
    { "complexity": "O(1)", "code": "def return_none():\n    return None" },
    { "complexity": "O(1)", "code": "def get_min(a, b):\n    return min(a, b)" },
    { "complexity": "O(1)", "code": "def get_max(a, b):\n    return max(a, b)" },
    { "complexity": "O(1)", "code": "def sum_two(a, b):\n    return a + b" },
    { "complexity": "O(1)", "code": "def is_upper(s):\n    return s.isupper()" },
    { "complexity": "O(1)", "code": "def is_lower(s):\n    return s.islower()" },
    { "complexity": "O(1)", "code": "def double_negation(b):\n    return not not b" },
    { "complexity": "O(1)", "code": "def set_to_list(s):\n    return list(s)" },
    { "complexity": "O(1)", "code": "def list_to_set(l):\n    return set(l)" },
    { "complexity": "O(1)", "code": "def int_to_str(n):\n    return str(n)" },
    { "complexity": "O(1)", "code": "def str_to_int(s):\n    return int(s)" },
    { "complexity": "O(1)", "code": "def get_bool(x):\n    return bool(x)" },
    { "complexity": "O(1)", "code": "def get_float(x):\n    return float(x)" },
    { "complexity": "O(1)", "code": "def get_first_char(s):\n    return s[0] if s else ''" },
    { "complexity": "O(1)", "code": "def get_last_char(s):\n    return s[-1] if s else ''" },
    { "complexity": "O(1)", "code": "def tuple_length(t):\n    return len(t)" },
    { "complexity": "O(1)", "code": "def list_empty(lst):\n    return len(lst) == 0" },
    { "complexity": "O(1)", "code": "def square(x):\n    return x * x" },
    { "complexity": "O(1)", "code": "def cube(x):\n    return x * x * x" },
    { "complexity": "O(1)", "code": "def get_type(obj):\n    return type(obj)" },
    { "complexity": "O(1)", "code": "def is_list(l):\n    return isinstance(l, list)" },
    { "complexity": "O(1)", "code": "def is_dict(d):\n    return isinstance(d, dict)" },
    { "complexity": "O(1)", "code": "def is_tuple(t):\n    return isinstance(t, tuple)" },
    { "complexity": "O(1)", "code": "def always_none():\n    return None" },
    { "complexity": "O(1)", "code": "def get_chr(n):\n    return chr(n)" },
    { "complexity": "O(1)", "code": "def get_ord(c):\n    return ord(c)" },
    {"code": "def get_last_element(lst):\n    return lst[-1]", "complexity": "O(1)"},
    {"code": "def multiply_by_two(n):\n    return n * 2", "complexity": "O(1)"},
    {"code": "def check_none(x):\n    return x is None", "complexity": "O(1)"},
    {"code": "def min_max(a, b):\n    return min(a, b), max(a, b)", "complexity": "O(1)"},
    {"code": "def always_true():\n    return True", "complexity": "O(1)"},
    {"code": "def negate(b):\n    return not b", "complexity": "O(1)"},
    {"code": "def return_pi():\n    return 3.1415", "complexity": "O(1)"},
    {"code": "def get_second(lst):\n    return lst[1] if len(lst) > 1 else None", "complexity": "O(1)"},
    {"code": "def swap(a, b):\n    return b, a", "complexity": "O(1)"},
    {"code": "def set_zero():\n    x = 0\n    return x", "complexity": "O(1)"},
 
    { "complexity": "O(n)", "code": "def sum_list(lst):\n    total = 0\n    for x in lst:\n        total += x\n    return total" },
    { "complexity": "O(n)", "code": "def count_even(lst):\n    count = 0\n    for x in lst:\n        if x % 2 == 0:\n            count += 1\n    return count" },
    { "complexity": "O(n)", "code": "def find_max(lst):\n    max_v = lst[0]\n    for x in lst:\n        if x > max_v:\n            max_v = x\n    return max_v" },
    { "complexity": "O(n)", "code": "def reverse_list(lst):\n    return lst[::-1]" },
    { "complexity": "O(n)", "code": "def remove_negatives(lst):\n    return [x for x in lst if x >= 0]" },
    { "complexity": "O(n)", "code": "def capitalize_words(lst):\n    return [w.capitalize() for w in lst]" },
    { "complexity": "O(n)", "code": "def all_positive(lst):\n    for x in lst:\n        if x <= 0:\n            return False\n    return True" },
    { "complexity": "O(n)", "code": "def filter_even(lst):\n    return [x for x in lst if x % 2 == 0]" },
    { "complexity": "O(n)", "code": "def product_list(lst):\n    result = 1\n    for x in lst:\n        result *= x\n    return result" },
    { "complexity": "O(n)", "code": "def average(lst):\n    return sum(lst) / len(lst) if lst else 0" },
    { "complexity": "O(n)", "code": "def count_occurrences(lst, v):\n    c = 0\n    for x in lst:\n        if x == v:\n            c += 1\n    return c" },
    { "complexity": "O(n)", "code": "def find_first_positive(lst):\n    for x in lst:\n        if x > 0:\n            return x\n    return None" },
    { "complexity": "O(n)", "code": "def list_to_string(lst):\n    return ''.join(str(x) for x in lst)" },
    { "complexity": "O(n)", "code": "def split_words(s):\n    return s.split()" },
    { "complexity": "O(n)", "code": "def copy_list(lst):\n    return [x for x in lst]" },
    { "complexity": "O(n)", "code": "def find_min(lst):\n    min_v = lst[0]\n    for x in lst:\n        if x < min_v:\n            min_v = x\n    return min_v" },
    { "complexity": "O(n)", "code": "def longest_string(lst):\n    longest = ''\n    for s in lst:\n        if len(s) > len(longest):\n            longest = s\n    return longest" },
    { "complexity": "O(n)", "code": "def find_last(lst, target):\n    idx = -1\n    for i, x in enumerate(lst):\n        if x == target:\n            idx = i\n    return idx" },
    { "complexity": "O(n)", "code": "def sum_abs(lst):\n    return sum(abs(x) for x in lst)" },
    { "complexity": "O(n)", "code": "def zero_out(lst):\n    for i in range(len(lst)):\n        lst[i] = 0\n    return lst" },
    { "complexity": "O(n)", "code": "def normalize(lst):\n    max_val = max(lst)\n    return [x / max_val for x in lst]" },
    { "complexity": "O(n)", "code": "def to_uppercase(lst):\n    return [s.upper() for s in lst]" },
    { "complexity": "O(n)", "code": "def count_letters(s):\n    return sum(1 for c in s if c.isalpha())" },
    { "complexity": "O(n)", "code": "def is_palindrome(s):\n    return s == s[::-1]" },
    { "complexity": "O(n)", "code": "def digits_sum(n):\n    return sum(int(d) for d in str(abs(n)))" },
    { "complexity": "O(n)", "code": "def flatten(lst):\n    return [item for sublist in lst for item in sublist]" },
    { "complexity": "O(n)", "code": "def count_spaces(s):\n    return s.count(' ')" },
    { "complexity": "O(n)", "code": "def count_unique(lst):\n    return len(set(lst))" },
    { "complexity": "O(n)", "code": "def count_vowels(s):\n    return sum(1 for c in s.lower() if c in 'aeiou')" },
    { "complexity": "O(n)", "code": "def count_consonants(s):\n    return sum(1 for c in s.lower() if c.isalpha() and c not in 'aeiou')" },
    { "complexity": "O(n)", "code": "def count_digits(s):\n    return sum(1 for c in s if c.isdigit())" },
    { "complexity": "O(n)", "code": "def count_uppercase(s):\n    return sum(1 for c in s if c.isupper())" },
    { "complexity": "O(n)", "code": "def count_lowercase(s):\n    return sum(1 for c in s if c.islower())" },
    { "complexity": "O(n)", "code": "def remove_spaces(s):\n    return ''.join(c for c in s if c != ' ')" },
    { "complexity": "O(n)", "code": "def remove_punctuation(s):\n    import string\n    return ''.join(c for c in s if c not in string.punctuation)" },
    { "complexity": "O(n)", "code": "def count_words(s):\n    return len(s.split())" },
    { "complexity": "O(n)", "code": "def to_lowercase(lst):\n    return [s.lower() for s in lst]" },
    { "complexity": "O(n)", "code": "def squares(lst):\n    return [x*x for x in lst]" },
    { "complexity": "O(n)", "code": "def cubes(lst):\n    return [x*x*x for x in lst]" },
    { "complexity": "O(n)", "code": "def calculate_prefix_sums(lst):\n    prefix = []\n    total = 0\n    for x in lst:\n        total += x\n        prefix.append(total)\n    return prefix" },
    { "complexity": "O(n)", "code": "def count_true(lst):\n    return sum(1 for x in lst if x)" },
    { "complexity": "O(n)", "code": "def find_indices(lst, v):\n    return [i for i, x in enumerate(lst) if x == v]" },
    { "complexity": "O(n)", "code": "def strip_whitespace(lst):\n    return [x.strip() for x in lst]" },
    { "complexity": "O(n)", "code": "def increment_all(lst):\n    return [x+1 for x in lst]" },
    { "complexity": "O(n)", "code": "def decrement_all(lst):\n    return [x-1 for x in lst]" },
    { "complexity": "O(n)", "code": "def multiply_by_index(lst):\n    return [i*x for i, x in enumerate(lst)]" },
    { "complexity": "O(n)", "code": "def reverse_string(s):\n    return s[::-1]" },
    { "complexity": "O(n)", "code": "def filter_positive(lst):\n    return [x for x in lst if x > 0]" },
    { "complexity": "O(n)", "code": "def running_average(lst):\n    result = []\n    s = 0\n    for i, x in enumerate(lst, 1):\n        s += x\n        result.append(s/i)\n    return result" },
    {"code": "def reverse_list(lst):\n    for i in range(len(lst)//2):\n        lst[i], lst[-i-1] = lst[-i-1], lst[i]\n    return lst", "complexity": "O(n)"},
    {"code": "def print_list(a):\n    for x in a:\n        print(x)", "complexity": "O(n)"},
    {"code": "def to_upper(strings):\n    return [s.upper() for s in strings]", "complexity": "O(n)"},
    {"code": "def find_even(a):\n    for x in a:\n        if x % 2 == 0:\n            return x", "complexity": "O(n)"},
    {"code": "def sum_abs(a):\n    s = 0\n    for x in a:\n        s += abs(x)\n    return s", "complexity": "O(n)"},
    {"code": "def remove_negatives(a):\n    return [x for x in a if x >= 0]", "complexity": "O(n)"},
    {"code": "def count_vowels(s):\n    return sum(1 for c in s if c in 'aeiou')", "complexity": "O(n)"},
    {"code": "def find_max_index(a):\n    m, idx = a[0], 0\n    for i, x in enumerate(a):\n        if x > m:\n            m, idx = x, i\n    return idx", "complexity": "O(n)"},
    {"code": "def all_positive(a):\n    return all(x > 0 for x in a)", "complexity": "O(n)"},
    {"code": "def double_all(a):\n    return [2*x for x in a]", "complexity": "O(n)"},
    {"code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr", "complexity": "O(n^2)"},
    {"code": "def selection_sort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr", "complexity": "O(n^2)"},
    {"code": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j >= 0 and key < arr[j]:\n            arr[j+1] = arr[j]\n            j -= 1\n        arr[j+1] = key\n    return arr", "complexity": "O(n^2)"},
    {"code": "def all_pairs(a):\n    pairs = []\n    for i in a:\n        for j in a:\n            pairs.append((i, j))\n    return pairs", "complexity": "O(n^2)"},
    {"code": "def unique_pairs(lst):\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            pairs.append((lst[i], lst[j]))\n    return pairs", "complexity": "O(n^2)"},
    {"code": "def duplicate_count(arr):\n    cnt = 0\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j and arr[i] == arr[j]:\n                cnt += 1\n    return cnt // 2", "complexity": "O(n^2)"},
    {"code": "def is_substring(a, b):\n    for i in range(len(a) - len(b) + 1):\n        for j in range(len(b)):\n            if a[i+j] != b[j]:\n                break\n        else:\n            return True\n    return False", "complexity": "O(n^2)"},
    {"code": "def find_duplicates(a):\n    dups = []\n    for i in range(len(a)):\n        for j in range(i+1, len(a)):\n            if a[i] == a[j]:\n                dups.append(a[i])\n    return dups", "complexity": "O(n^2)"},
    {"code": "def nested_sum(a):\n    s = 0\n    for i in a:\n        for j in a:\n            s += i + j\n    return s", "complexity": "O(n^2)"},
    {"code": "def all_pairs_matrix(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = i + j", "complexity": "O(n^2)"},
    { "complexity": "O(n^2)", "code": "def bubble_sort(lst):\n    n = len(lst)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if lst[j] > lst[j+1]:\n                lst[j], lst[j+1] = lst[j+1], lst[j]\n    return lst" },
    { "complexity": "O(n^2)", "code": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr" },
    { "complexity": "O(n^2)", "code": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr" },
    { "complexity": "O(n^2)", "code": "def has_duplicates_brute(lst):\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j]:\n                return True\n    return False" },
    { "complexity": "O(n^2)", "code": "def count_inversions(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count" },
    { "complexity": "O(n^2)", "code": "def find_all_anagrams(lst):\n    anagrams = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if sorted(lst[i]) == sorted(lst[j]):\n                anagrams.append((lst[i], lst[j]))\n    return anagrams" },
    { "complexity": "O(n^2)", "code": "def most_frequent_brute(lst):\n    max_count = 0\n    max_elem = lst[0]\n    for i in lst:\n        count = 0\n        for j in lst:\n            if j == i:\n                count += 1\n        if count > max_count:\n            max_count = count\n            max_elem = i\n    return max_elem" },
    { "complexity": "O(n^2)", "code": "def upper_triangle_sum(mat):\n    n = len(mat)\n    s = 0\n    for i in range(n):\n        for j in range(i, n):\n            s += mat[i][j]\n    return s" },
    { "complexity": "O(n^2)", "code": "def lower_triangular(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(i):\n            mat[i][j] = 0\n    return mat" },
    { "complexity": "O(n^2)", "code": "def multiply_vectors(a, b):\n    return [[x*y for y in b] for x in a]" },
    { "complexity": "O(n^2)", "code": "def diagonal_difference(mat):\n    n = len(mat)\n    d1 = d2 = 0\n    for i in range(n):\n        d1 += mat[i][i]\n        d2 += mat[i][n-i-1]\n    return abs(d1-d2)" },
    { "complexity": "O(n^2)", "code": "def count_zeros_matrix(mat):\n    count = 0\n    for row in mat:\n        for val in row:\n            if val == 0:\n                count += 1\n    return count" },
    { "complexity": "O(n^2)", "code": "def is_symmetric(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] != mat[j][i]:\n                return False\n    return True" },
    { "complexity": "O(n^2)", "code": "def matrix_addition(a, b):\n    n = len(a)\n    result = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[i][j] = a[i][j] + b[i][j]\n    return result" },
    { "complexity": "O(n^2)", "code": "def matrix_multiply(a, b):\n    n = len(a)\n    res = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                res[i][j] += a[i][k]*b[k][j]\n    return res" },
    { "complexity": "O(n^2)", "code": "def transpose_matrix(mat):\n    n = len(mat)\n    res = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            res[j][i] = mat[i][j]\n    return res" },
    { "complexity": "O(n^2)", "code": "def all_pairs(lst):\n    pairs = []\n    for i in lst:\n        for j in lst:\n            pairs.append((i, j))\n    return pairs" },
    { "complexity": "O(n^2)", "code": "def multiply_square_matrices(a, b):\n    n = len(a)\n    result = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                result[i][j] += a[i][k] * b[k][j]\n    return result" },
    { "complexity": "O(n^2)", "code": "def identity_matrix(n):\n    mat = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                mat[i][j] = 1\n    return mat" },
    { "complexity": "O(n^2)", "code": "def find_pairs_sum(lst, t):\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] + lst[j] == t:\n                pairs.append((lst[i], lst[j]))\n    return pairs" },
    { "complexity": "O(n^2)", "code": "def count_common(a, b):\n    count = 0\n    for x in a:\n        for y in b:\n            if x == y:\n                count += 1\n    return count" },
    { "complexity": "O(n^2)", "code": "def rotate_matrix(matrix):\n    n = len(matrix)\n    result = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[j][n-1-i] = matrix[i][j]\n    return result" },
    { "complexity": "O(n^2)", "code": "def lower_triangle_sum(mat):\n    n = len(mat)\n    s = 0\n    for i in range(n):\n        for j in range(i+1):\n            s += mat[i][j]\n    return s" },
    { "complexity": "O(n^2)", "code": "def find_duplicate_pairs(lst):\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j]:\n                pairs.append((i, j))\n    return pairs" },
    { "complexity": "O(n^2)", "code": "def matrix_diagonal_sum(matrix):\n    total = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix)):\n            if i == j:\n                total += matrix[i][j]\n    return total" },
    { "complexity": "O(n^2)", "code": "def matrix_identity_check(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(n):\n            if (i == j and mat[i][j] != 1) or (i != j and mat[i][j] != 0):\n                return False\n    return True" },
    { "complexity": "O(n^2)", "code": "def sum_matrix(a):\n    s = 0\n    for i in range(len(a)):\n        for j in range(len(a)):\n            s += a[i][j]\n    return s" },
    { "complexity": "O(n^2)", "code": "def invert_matrix(m):\n    n = len(m)\n    result = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[j][n-1-i] = m[i][j]\n    return result" },
    { "complexity": "O(n^2)", "code": "def find_all_anagram_pairs(lst):\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if sorted(lst[i]) == sorted(lst[j]):\n                pairs.append((i, j))\n    return pairs" },
    { "complexity": "O(n^2)", "code": "def count_upper_triangular(mat):\n    n = len(mat)\n    s = 0\n    for i in range(n):\n        for j in range(i, n):\n            s += mat[i][j]\n    return s" },
    { "complexity": "O(n^2)", "code": "def lower_triangular_fill(mat):\n    n = len(mat)\n    result = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1):\n            result[i][j] = mat[i][j]\n    return result" },
    { "complexity": "O(n^2)", "code": "def sum_of_pairwise_products(lst):\n    total = 0\n    for i in range(len(lst)):\n        for j in range(len(lst)):\n            total += lst[i] * lst[j]\n    return total" },
    { "complexity": "O(n^2)", "code": "def print_pairs(lst):\n    for i in lst:\n        for j in lst:\n            print(i, j)" },
    { "complexity": "O(n^2)", "code": "def sum_distances(lst):\n    s = 0\n    for i in range(len(lst)):\n        for j in range(len(lst)):\n            s += abs(lst[i] - lst[j])\n    return s" },
    { "complexity": "O(n^2)", "code": "def count_equal_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j]:\n                count += 1\n    return count" },
    { "complexity": "O(n^2)", "code": "def check_symmetric_pairs(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] != mat[j][i]:\n                return False\n    return True" },
    { "complexity": "O(n^2)", "code": "def all_unique_pairs(lst):\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            pairs.append((lst[i], lst[j]))\n    return pairs" },
    { "complexity": "O(n^2)", "code": "def all_triplets(lst):\n    triplets = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            for k in range(j+1, len(lst)):\n                triplets.append((lst[i], lst[j], lst[k]))\n    return triplets" },
    { "complexity": "O(n^2)", "code": "def count_palindrome_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            s = lst[i] + lst[j]\n            if s == s[::-1]:\n                count += 1\n    return count" },
    { "complexity": "O(n^2)", "code": "def compare_all_strings(lst):\n    n = len(lst)\n    for i in range(n):\n        for j in range(n):\n            if lst[i] < lst[j]:\n                pass" },
    { "complexity": "O(n^2)", "code": "def similarity_matrix(words):\n    n = len(words)\n    matrix = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = sum(a==b for a,b in zip(words[i], words[j]))\n    return matrix" },
    { "complexity": "O(n^2)", "code": "def distance_matrix(points):\n    n = len(points)\n    mat = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = abs(points[i] - points[j])\n    return mat" },
    { "complexity": "O(n^2)", "code": "def is_magic_square(mat):\n    n = len(mat)\n    s = sum(mat[0])\n    for i in range(n):\n        if sum(mat[i]) != s:\n            return False\n        if sum(mat[j][i] for j in range(n)) != s:\n            return False\n    return True" },
    { "complexity": "O(n^2)", "code": "def max_submatrix_sum(mat):\n    n = len(mat)\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(n):\n            total = 0\n            for k in range(i, n):\n                for l in range(j, n):\n                    total += mat[k][l]\n            if total > max_sum:\n                max_sum = total\n    return max_sum" },
    { "complexity": "O(n^2)", "code": "def count_occurrences_matrix(mat, val):\n    count = 0\n    for row in mat:\n        for elem in row:\n            if elem == val:\n                count += 1\n    return count" },
    { "complexity": "O(n^2)", "code": "def multiply_diagonals(mat):\n    n = len(mat)\n    prod1 = prod2 = 1\n    for i in range(n):\n        prod1 *= mat[i][i]\n        prod2 *= mat[i][n-i-1]\n    return prod1 * prod2" },
    { "complexity": "O(n^2)", "code": "def count_char_matches(a, b):\n    count = 0\n    for i in range(len(a)):\n        for j in range(len(b)):\n            if a[i] == b[j]:\n                count += 1\n    return count" },
    { "complexity": "O(n^2)", "code": "def is_transitive_relation(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j]:\n                for k in range(n):\n                    if mat[j][k] and not mat[i][k]:\n                        return False\n    return True" },
    { "complexity": "O(log n)", "code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1" },
    { "complexity": "O(log n)", "code": "def sqrt_integer(n):\n    left, right = 0, n\n    result = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid <= n:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result" },
    { "complexity": "O(log n)", "code": "def power_of_two_floor(n):\n    res = 1\n    while res * 2 <= n:\n        res *= 2\n    return res" },
    { "complexity": "O(log n)", "code": "def fast_power(base, exp):\n    res = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            res *= base\n        base *= base\n        exp //= 2\n    return res" },
    { "complexity": "O(log n)", "code": "def log2_floor(n):\n    cnt = 0\n    while n > 1:\n        n //= 2\n        cnt += 1\n    return cnt" },
    { "complexity": "O(log n)", "code": "def find_first_ge(arr, target):\n    l, r, ans = 0, len(arr) - 1, -1\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] >= target:\n            ans = m\n            r = m - 1\n        else:\n            l = m + 1\n    return ans" },
    { "complexity": "O(log n)", "code": "def last_le(arr, target):\n    l, r, ans = 0, len(arr) - 1, -1\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] <= target:\n            ans = m\n            l = m + 1\n        else:\n            r = m - 1\n    return ans" },
    { "complexity": "O(log n)", "code": "def find_rotation_point(arr):\n    l, r = 0, len(arr) - 1\n    while l < r:\n        m = (l + r) // 2\n        if arr[m] > arr[r]:\n            l = m + 1\n        else:\n            r = m\n    return l" },
    { "complexity": "O(log n)", "code": "def int_kth_root(n, k):\n    l, r = 0, n\n    res = 0\n    while l <= r:\n        m = (l + r) // 2\n        if m ** k <= n:\n            res = m\n            l = m + 1\n        else:\n            r = m - 1\n    return res" },
    { "complexity": "O(log n)", "code": "def find_peak_unimodal(arr):\n    l, r = 0, len(arr) - 1\n    while l < r:\n        m = (l + r) // 2\n        if arr[m] < arr[m + 1]:\n            l = m + 1\n        else:\n            r = m\n    return l" },
    { "complexity": "O(log n)", "code": "def find_missing_number(arr):\n    l, r = 0, len(arr)\n    while l < r:\n        m = (l + r) // 2\n        if arr[m] == m:\n            l = m + 1\n        else:\n            r = m\n    return l" },
    { "complexity": "O(log n)", "code": "def find_closest(arr, target):\n    l, r = 0, len(arr) - 1\n    best = arr[0]\n    while l <= r:\n        m = (l + r) // 2\n        if abs(arr[m] - target) < abs(best - target):\n            best = arr[m]\n        if arr[m] < target:\n            l = m + 1\n        elif arr[m] > target:\n            r = m - 1\n        else:\n            break\n    return best" },
    { "complexity": "O(log n)", "code": "def find_insert_position(arr, target):\n    l, r = 0, len(arr)\n    while l < r:\n        m = (l + r) // 2\n        if arr[m] < target:\n            l = m + 1\n        else:\n            r = m\n    return l" },
    { "complexity": "O(log n)", "code": "def find_single_element(arr):\n    l, r = 0, len(arr) - 1\n    while l < r:\n        m = (l + r) // 2\n        if m % 2 == 1:\n            m -= 1\n        if arr[m] == arr[m + 1]:\n            l = m + 2\n        else:\n            r = m\n    return arr[l]" },
    { "complexity": "O(log n)", "code": "def integer_log_base_k(n, k):\n    res = 0\n    while n >= k:\n        n //= k\n        res += 1\n    return res" },
    { "complexity": "O(log n)", "code": "def find_rotation_in_string(lst):\n    l, r = 0, len(lst) - 1\n    while l < r:\n        m = (l + r) // 2\n        if lst[m] > lst[r]:\n            l = m + 1\n        else:\n            r = m\n    return l" },
    { "complexity": "O(log n)", "code": "def count_digits_binary(n):\n    count = 0\n    while n:\n        n //= 2\n        count += 1\n    return count" },
    { "complexity": "O(log n)", "code": "def find_power_of_two(n):\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n    return True" },
    { "complexity": "O(log n)", "code": "def find_last_occurrence(arr, target):\n    l, r, ans = 0, len(arr) - 1, -1\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] <= target:\n            if arr[m] == target:\n                ans = m\n            l = m + 1\n        else:\n            r = m - 1\n    return ans" },
    { "complexity": "O(log n)", "code": "def find_first_occurrence(arr, target):\n    l, r, ans = 0, len(arr) - 1, -1\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] >= target:\n            if arr[m] == target:\n                ans = m\n            r = m - 1\n        else:\n            l = m + 1\n    return ans" },
    { "complexity": "O(log n)", "code": "def sqrt_float(n, eps=1e-6):\n    l, r = 0, n\n    while r - l > eps:\n        m = (l + r) / 2\n        if m * m < n:\n            l = m\n        else:\n            r = m\n    return l" },
    { "complexity": "O(log n)", "code": "def find_kth_smallest(arr, k):\n    arr = sorted(arr)\n    return arr[k-1]" },
    { "complexity": "O(log n)", "code": "def search_range(arr, target):\n    def find_first():\n        l, r, ans = 0, len(arr) - 1, -1\n        while l <= r:\n            m = (l + r) // 2\n            if arr[m] >= target:\n                if arr[m] == target:\n                    ans = m\n                r = m - 1\n            else:\n                l = m + 1\n        return ans\n    def find_last():\n        l, r, ans = 0, len(arr) - 1, -1\n        while l <= r:\n            m = (l + r) // 2\n            if arr[m] <= target:\n                if arr[m] == target:\n                    ans = m\n                l = m + 1\n            else:\n                r = m - 1\n        return ans\n    return [find_first(), find_last()]" },
    { "complexity": "O(log n)", "code": "def find_duplicate_in_sorted(arr):\n    l, r = 0, len(arr) - 2\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] == arr[m + 1]:\n            return arr[m]\n        elif arr[m] < arr[m + 1]:\n            l = m + 1\n        else:\n            r = m - 1\n    return None" },
    { "complexity": "O(log n)", "code": "def is_perfect_square(n):\n    l, r = 1, n\n    while l <= r:\n        m = (l + r) // 2\n        if m * m == n:\n            return True\n        elif m * m < n:\n            l = m + 1\n        else:\n            r = m - 1\n    return False" },
    { "complexity": "O(log n)", "code": "def find_smallest_greater(arr, target):\n    l, r, ans = 0, len(arr) - 1, -1\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] > target:\n            ans = m\n            r = m - 1\n        else:\n            l = m + 1\n    return ans" },
    { "complexity": "O(log n)", "code": "def find_largest_smaller(arr, target):\n    l, r, ans = 0, len(arr) - 1, -1\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] < target:\n            ans = m\n            l = m + 1\n        else:\n            r = m - 1\n    return ans" },
    { "complexity": "O(log n)", "code": "def nth_root(n, k):\n    l, r = 0, n\n    while l <= r:\n        m = (l + r) // 2\n        pow_m = m ** k\n        if pow_m == n:\n            return m\n        elif pow_m < n:\n            l = m + 1\n        else:\n            r = m - 1\n    return r" },
    { "complexity": "O(log n)", "code": "def find_bitonic_max(arr):\n    l, r = 0, len(arr) - 1\n    while l < r:\n        m = (l + r) // 2\n        if arr[m] < arr[m + 1]:\n            l = m + 1\n        else:\n            r = m\n    return arr[l]" },
    { "complexity": "O(log n)", "code": "def find_rotation_count(arr):\n    l, r = 0, len(arr) - 1\n    n = len(arr)\n    while l <= r:\n        if arr[l] <= arr[r]:\n            return l\n        m = (l + r) // 2\n        next_ = (m + 1) % n\n        prev = (m + n - 1) % n\n        if arr[m] <= arr[next_] and arr[m] <= arr[prev]:\n            return m\n        elif arr[m] <= arr[r]:\n            r = m - 1\n        else:\n            l = m + 1\n    return 0" },
    { "complexity": "O(log n)", "code": "def find_min_in_rotated(arr):\n    l, r = 0, len(arr) - 1\n    while l < r:\n        m = (l + r) // 2\n        if arr[m] > arr[r]:\n            l = m + 1\n        else:\n            r = m\n    return arr[l]" },
    { "complexity": "O(log n)", "code": "def find_max_in_rotated(arr):\n    l, r = 0, len(arr) - 1\n    while l < r:\n        m = (l + r + 1) // 2\n        if arr[m] > arr[0]:\n            l = m\n        else:\n            r = m - 1\n    return arr[l]" },
    { "complexity": "O(log n)", "code": "def power_with_mod(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result" },
    { "complexity": "O(log n)", "code": "def is_kth_bit_set(n, k):\n    return (n >> k) & 1" },
    { "complexity": "O(log n)", "code": "def find_next_power_of_two(n):\n    res = 1\n    while res < n:\n        res <<= 1\n    return res" },
    { "complexity": "O(log n)", "code": "def find_highest_power_of_2(n):\n    res = 1\n    while res * 2 <= n:\n        res *= 2\n    return res" },
    { "complexity": "O(log n)", "code": "def find_element_in_infinite_array(arr, target):\n    l, r = 0, 1\n    while r < len(arr) and arr[r] < target:\n        l = r\n        r *= 2\n    while l <= r:\n        m = (l + r) // 2\n        if m >= len(arr):\n            r = m - 1\n            continue\n        if arr[m] == target:\n            return m\n        elif arr[m] < target:\n            l = m + 1\n        else:\n            r = m - 1\n    return -1" },
    { "complexity": "O(log n)", "code": "def find_local_minimum(arr):\n    l, r = 0, len(arr) - 1\n    n = len(arr)\n    while l <= r:\n        m = (l + r) // 2\n        if (m == 0 or arr[m-1] > arr[m]) and (m == n-1 or arr[m+1] > arr[m]):\n            return m\n        elif m > 0 and arr[m-1] < arr[m]:\n            r = m - 1\n        else:\n            l = m + 1\n    return -1" },
    { "complexity": "O(log n)", "code": "def find_element_in_bitonic(arr, target):\n    def find_peak():\n        l, r = 0, len(arr) - 1\n        while l < r:\n            m = (l + r) // 2\n            if arr[m] < arr[m+1]:\n                l = m + 1\n            else:\n                r = m\n        return l\n    peak = find_peak()\n    l, r = 0, peak\n    # search in increasing part\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] == target:\n            return m\n        elif arr[m] < target:\n            l = m + 1\n        else:\n            r = m - 1\n    l, r = peak + 1, len(arr) - 1\n    # search in decreasing part\n    while l <= r:\n        m = (l + r) // 2\n        if arr[m] == target:\n            return m\n        elif arr[m] > target:\n            l = m + 1\n        else:\n            r = m - 1\n    return -1" }
, {"code": "def find_log_base2(n):\n    steps = 0\n    while n > 1:\n        n //= 2\n        steps += 1\n    return steps", "complexity": "O(log n)"},
    {"code": "def int_log(n, base):\n    res = 0\n    while n > 1:\n        n //= base\n        res += 1\n    return res", "complexity": "O(log n)"},
    {"code": "def find_power_of_ten(n):\n    while n >= 10:\n        n //= 10\n    return n", "complexity": "O(log n)"},
    {"code": "def right_shift_log(n):\n    c = 0\n    while n > 0:\n        n >>= 1\n        c += 1\n    return c", "complexity": "O(log n)"},
    {"code": "def halve_until_zero(n):\n    while n > 0:\n        n //= 2", "complexity": "O(log n)"},
    {"code": "def divide_by_three(n):\n    count = 0\n    while n > 1:\n        n //= 3\n        count += 1\n    return count", "complexity": "O(log n)"},
    {"code": "def log_search(lst, target):\n    l, r = 0, len(lst)-1\n    while l <= r:\n        m = (l+r)//2\n        if lst[m] == target:\n            return m\n        elif lst[m] < target:\n            l = m+1\n        else:\n            r = m-1\n    return -1", "complexity": "O(log n)"},
    {"code": "def ceil_log2(n):\n    k = 0\n    while (1<<k) < n:\n        k += 1\n    return k", "complexity": "O(log n)"},
    {"code": "def count_bits(n):\n    count = 0\n    while n:\n        n &= n-1\n        count += 1\n    return count", "complexity": "O(log n)"},
    {"code": "def get_digit_count(n):\n    c = 0\n    while n:\n        n //= 10\n        c += 1\n    return c", "complexity": "O(log n)"},
    { "complexity": "O(n log n)", "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result" },
    { "complexity": "O(n log n)", "code": "def quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[0]\n    left = [x for x in arr[1:] if x < pivot]\n    right = [x for x in arr[1:] if x >= pivot]\n    return quicksort(left) + [pivot] + quicksort(right)" },
    { "complexity": "O(n log n)", "code": "def heap_sort(arr):\n    import heapq\n    h = arr[:]\n    heapq.heapify(h)\n    return [heapq.heappop(h) for _ in range(len(h))]" },
    { "complexity": "O(n log n)", "code": "def sort_and_remove_duplicates(arr):\n    return sorted(set(arr))" },
    { "complexity": "O(n log n)", "code": "def sort_strings_alphabetically(lst):\n    return sorted(lst)" },
    { "complexity": "O(n log n)", "code": "def sort_by_length(lst):\n    return sorted(lst, key=len)" },
    { "complexity": "O(n log n)", "code": "def external_sort(arr):\n    return sorted(arr)" },
    { "complexity": "O(n log n)", "code": "def stable_sort(arr):\n    return sorted(arr, key=lambda x: (x[0], x[1]))" },
    { "complexity": "O(n log n)", "code": "def sort_by_abs(lst):\n    return sorted(lst, key=abs)" },
    { "complexity": "O(n log n)", "code": "def sort_and_capitalize(lst):\n    return [s.capitalize() for s in sorted(lst)]" },
    { "complexity": "O(n log n)", "code": "def count_inversions(arr):\n    def merge_count(a):\n        if len(a) <= 1:\n            return a, 0\n        m = len(a) // 2\n        l, il = merge_count(a[:m])\n        r, ir = merge_count(a[m:])\n        merged, count = [], il + ir\n        i = j = 0\n        while i < len(l) and j < len(r):\n            if l[i] <= r[j]: merged.append(l[i]); i += 1\n            else: merged.append(r[j]); j += 1; count += len(l)-i\n        merged.extend(l[i:]); merged.extend(r[j:])\n        return merged, count\n    return merge_count(arr)[1]" },
    { "complexity": "O(n log n)", "code": "def sort_by_frequency(arr):\n    from collections import Counter\n    freq = Counter(arr)\n    return sorted(arr, key=lambda x: (-freq[x], x))" },
    { "complexity": "O(n log n)", "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_end = merged[-1][1]\n        if start <= last_end:\n            merged[-1][1] = max(last_end, end)\n        else:\n            merged.append([start, end])\n    return merged" },
    { "complexity": "O(n log n)", "code": "def kth_smallest_sort(arr, k):\n    return sorted(arr)[k-1]" },
    { "complexity": "O(n log n)", "code": "def group_anagrams(words):\n    from collections import defaultdict\n    groups = defaultdict(list)\n    for word in words:\n        groups[''.join(sorted(word))].append(word)\n    return list(groups.values())" },
    { "complexity": "O(n log n)", "code": "def find_max_overlap(intervals):\n    events = []\n    for start, end in intervals:\n        events.append((start, 1))\n        events.append((end, -1))\n    events.sort()\n    curr = max_overlap = 0\n    for _, e in events:\n        curr += e\n        max_overlap = max(max_overlap, curr)\n    return max_overlap" },
    { "complexity": "O(n log n)", "code": "def interval_union(intervals):\n    intervals.sort()\n    result = []\n    for interval in intervals:\n        if not result or result[-1][1] < interval[0]:\n            result.append(interval)\n        else:\n            result[-1][1] = max(result[-1][1], interval[1])\n    return result" },
    { "complexity": "O(n log n)", "code": "def closest_pair(points):\n    points.sort()\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i+1, min(i+8, len(points))):\n            dist = abs(points[i] - points[j])\n            min_dist = min(min_dist, dist)\n    return min_dist" },
    { "complexity": "O(n log n)", "code": "def frequency_sort(s):\n    from collections import Counter\n    freq = Counter(s)\n    return ''.join([char * freq[char] for char in sorted(freq, key=lambda x: -freq[x])])" },
    { "complexity": "O(n log n)", "code": "def top_k_frequent(nums, k):\n    from collections import Counter\n    return [item for item, _ in Counter(nums).most_common(k)]" },
    { "complexity": "O(n log n)", "code": "def min_meeting_rooms(intervals):\n    if not intervals:\n        return 0\n    start = sorted([i[0] for i in intervals])\n    end = sorted([i[1] for i in intervals])\n    s = e = rooms = 0\n    while s < len(intervals):\n        if start[s] < end[e]:\n            rooms += 1\n            s += 1\n        else:\n            e += 1\n            s += 1\n    return rooms" },
    { "complexity": "O(n log n)", "code": "def minimum_number_of_arrows(points):\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n    for s, e in points[1:]:\n        if s > end:\n            arrows += 1\n            end = e\n    return arrows" },
    { "complexity": "O(n log n)", "code": "def sort_and_merge(arr1, arr2):\n    return sorted(arr1 + arr2)" },
    { "complexity": "O(n log n)", "code": "def max_meetings(intervals):\n    intervals.sort(key=lambda x: x[1])\n    end = float('-inf')\n    count = 0\n    for start, finish in intervals:\n        if start > end:\n            count += 1\n            end = finish\n    return count" },
    { "complexity": "O(n log n)", "code": "def sort_by_parity(arr):\n    return sorted(arr, key=lambda x: x % 2)" },
    { "complexity": "O(n log n)", "code": "def sort_by_custom_order(arr, order):\n    order_map = {v: i for i, v in enumerate(order)}\n    return sorted(arr, key=lambda x: order_map.get(x, len(order)))" },
    { "complexity": "O(n log n)", "code": "def sort_tuples_by_second(tuples):\n    return sorted(tuples, key=lambda x: x[1])" },
    { "complexity": "O(n log n)", "code": "def sort_students_by_grade(students):\n    return sorted(students, key=lambda x: (-x[1], x[0]))" },
    { "complexity": "O(n log n)", "code": "def sort_dict_by_value(d):\n    return sorted(d.items(), key=lambda item: item[1])" },
    { "complexity": "O(n log n)", "code": "def sort_words_by_length(words):\n    return sorted(words, key=lambda w: (len(w), w))" },
    { "complexity": "O(n log n)", "code": "def sort_points_by_distance(points):\n    return sorted(points, key=lambda p: p[0]**2 + p[1]**2)" },
    { "complexity": "O(n log n)", "code": "def sort_employees_by_salary(employees):\n    return sorted(employees, key=lambda x: x['salary'])" },
    { "complexity": "O(n log n)", "code": "def sort_events_by_date(events):\n    return sorted(events, key=lambda e: e['date'])" },
    { "complexity": "O(n log n)", "code": "def sort_by_second_last_char(lst):\n    return sorted(lst, key=lambda x: x[-2] if len(x) > 1 else '')" },
    { "complexity": "O(n log n)", "code": "def sort_numbers_desc(arr):\n    return sorted(arr, reverse=True)" },
    { "complexity": "O(n log n)", "code": "def sort_and_remove_negatives(arr):\n    return sorted([x for x in arr if x >= 0])" },
    { "complexity": "O(n log n)", "code": "def sort_by_multiple_keys(arr):\n    return sorted(arr, key=lambda x: (x[1], x[0]))" },
    { "complexity": "O(n log n)", "code": "def sort_by_word_count(sentences):\n    return sorted(sentences, key=lambda s: len(s.split()))" },
    { "complexity": "O(n log n)", "code": "def sort_by_unique_letters(words):\n    return sorted(words, key=lambda w: len(set(w)))" },
    { "complexity": "O(n log n)", "code": "def sort_numbers_by_trailing_zeros(arr):\n    def trailing_zeros(x):\n        count = 0\n        while x % 10 == 0 and x != 0:\n            x //= 10\n            count += 1\n        return count\n    return sorted(arr, key=trailing_zeros)" },
    { "complexity": "O(n log n)", "code": "def sort_by_ascii_sum(strings):\n    return sorted(strings, key=lambda s: sum(ord(c) for c in s))" },
    { "complexity": "O(n log n)", "code": "def sort_rectangles_by_area(rects):\n    return sorted(rects, key=lambda x: x[0]*x[1])" },
    { "complexity": "O(n log n)", "code": "def sort_points_by_angle(points):\n    import math\n    return sorted(points, key=lambda p: math.atan2(p[1], p[0]))" },
    { "complexity": "O(n log n)", "code": "def sort_books_by_title(books):\n    return sorted(books, key=lambda b: b['title'])" },
    { "complexity": "O(n log n)", "code": "def sort_students_by_multiple(students):\n    return sorted(students, key=lambda x: (x['grade'], x['age']))" },
    { "complexity": "O(n log n)", "code": "def sort_by_occurrence(arr):\n    from collections import Counter\n    count = Counter(arr)\n    return sorted(arr, key=lambda x: (count[x], x))" },
    { "complexity": "O(n log n)", "code": "def sort_files_by_size(files):\n    return sorted(files, key=lambda f: f['size'])" },
    { "complexity": "O(n log n)", "code": "def sort_tuples_by_sum(tuples):\n    return sorted(tuples, key=lambda t: sum(t))" },
    { "complexity": "O(n log n)", "code": "def sort_by_last_digit(arr):\n    return sorted(arr, key=lambda x: x % 10)" },
    { "complexity": "O(n log n)", "code": "def sort_by_digit_count(arr):\n    return sorted(arr, key=lambda x: len(str(abs(x))))" },
    { "complexity": "O(n log n)", "code": "def sort_by_first_char(lst):\n    return sorted(lst, key=lambda x: x[0] if x else '')" },
    { "complexity": "O(n log n)", "code": "def sort_by_reverse(arr):\n    return sorted(arr, key=lambda x: str(x)[::-1])" },
  { "complexity": "O(2^n)", "code": "def fibonacci_recursive(n):\n    if n <= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)" },
    { "complexity": "O(2^n)", "code": "def generate_subsets(lst):\n    res = [[]]\n    for x in lst:\n        res += [s + [x] for s in res]\n    return res" },
    { "complexity": "O(2^n)", "code": "def generate_permutations(lst):\n    if not lst:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for p in generate_permutations(lst[:i]+lst[i+1:]):\n            res.append([lst[i]]+p)\n    return res" },
    { "complexity": "O(2^n)", "code": "def subset_sum(lst, t):\n    res = []\n    def backtrack(i, acc, curr):\n        if acc == t:\n            res.append(curr[:]); return\n        if i == len(lst) or acc > t:\n            return\n        curr.append(lst[i])\n        backtrack(i+1, acc+lst[i], curr)\n        curr.pop()\n        backtrack(i+1, acc, curr)\n    backtrack(0, 0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def partitions(n):\n    def backtrack(rem, curr, max_val):\n        if rem == 0:\n            res.append(curr[:]); return\n        for i in range(1, min(rem, max_val)+1):\n            curr.append(i)\n            backtrack(rem-i, curr, i)\n            curr.pop()\n    res = []\n    backtrack(n, [], n)\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_binary_strings(n):\n    if n == 0: return ['']\n    return ['0'+s for s in all_binary_strings(n-1)] + ['1'+s for s in all_binary_strings(n-1)]" },
    { "complexity": "O(2^n)", "code": "def n_queens(n):\n    res = []\n    def backtrack(row, cols, diag1, diag2, board):\n        if row == n:\n            res.append([''.join(r) for r in board]); return\n        for c in range(n):\n            if c in cols or row-c in diag1 or row+c in diag2:\n                continue\n            board[row][c] = 'Q'\n            backtrack(row+1, cols|{c}, diag1|{row-c}, diag2|{row+c}, board)\n            board[row][c] = '.'\n    backtrack(0, set(), set(), set(), [['.']*n for _ in range(n)])\n    return res" },
    { "complexity": "O(2^n)", "code": "def generate_parentheses(n):\n    res = []\n    def backtrack(s, l, r):\n        if len(s) == 2*n:\n            res.append(s); return\n        if l < n: backtrack(s+'(', l+1, r)\n        if r < l: backtrack(s+')', l, r+1)\n    backtrack('',0,0)\n    return res" },
    { "complexity": "O(2^n)", "code": "def string_permutations(s):\n    if len(s) <= 1: return [s]\n    perms = []\n    for i, c in enumerate(s):\n        for perm in string_permutations(s[:i]+s[i+1:]):\n            perms.append(c+perm)\n    return perms" },
    { "complexity": "O(2^n)", "code": "def power_set(lst):\n    res = [[]]\n    for x in lst:\n        res += [s+[x] for s in res]\n    return res" },
    { "complexity": "O(2^n)", "code": "def knapsack_01(values, weights, cap):\n    def dfs(i, rem):\n        if i==len(values): return 0\n        if weights[i]>rem: return dfs(i+1, rem)\n        return max(dfs(i+1, rem), values[i]+dfs(i+1, rem-weights[i]))\n    return dfs(0, cap)" },
    { "complexity": "O(2^n)", "code": "def boolean_parenthesization(s):\n    if len(s) == 1:\n        return [s]\n    results = []\n    for i in range(1, len(s), 2):\n        left = boolean_parenthesization(s[:i])\n        right = boolean_parenthesization(s[i+1:])\n        for l in left:\n            for r in right:\n                results.append('(' + l + s[i] + r + ')')\n    return results" },
    { "complexity": "O(2^n)", "code": "def all_subsequences(s):\n    if s == '':\n        return ['']\n    rest = all_subsequences(s[1:])\n    return rest + [s[0] + subseq for subseq in rest]" },
    { "complexity": "O(2^n)", "code": "def all_combinations(nums):\n    res = []\n    def backtrack(i, path):\n        if i == len(nums):\n            res.append(path[:]); return\n        backtrack(i+1, path)\n        path.append(nums[i])\n        backtrack(i+1, path)\n        path.pop()\n    backtrack(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_coin_change(coins, amount):\n    res = []\n    def dfs(i, path, total):\n        if total == amount:\n            res.append(path[:]); return\n        if total > amount or i == len(coins):\n            return\n        path.append(coins[i])\n        dfs(i, path, total+coins[i])\n        path.pop()\n        dfs(i+1, path, total)\n    dfs(0, [], 0)\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_letter_cases(s):\n    res = ['']\n    for c in s:\n        if c.isalpha():\n            res = [r + ch for r in res for ch in [c.lower(), c.upper()]]\n        else:\n            res = [r + c for r in res]\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_balanced_parentheses(n):\n    res = []\n    def backtrack(s, l, r):\n        if len(s)==2*n:\n            res.append(s); return\n        if l<n: backtrack(s+'(',l+1,r)\n        if r<l: backtrack(s+')',l,r+1)\n    backtrack('',0,0)\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_partition_strings(s):\n    res = []\n    def dfs(i, path):\n        if i == len(s):\n            res.append(path[:]); return\n        for j in range(i+1, len(s)+1):\n            dfs(j, path+[s[i:j]])\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_path_maze(n, m):\n    res = []\n    def dfs(i, j, path):\n        if i == n-1 and j == m-1:\n            res.append(path[:]); return\n        if i+1 < n: dfs(i+1, j, path+['D'])\n        if j+1 < m: dfs(i, j+1, path+['R'])\n    dfs(0, 0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_binary_partitions(n):\n    res = []\n    def dfs(i, curr):\n        if i == n:\n            res.append(curr[:]); return\n        for b in [0,1]:\n            curr.append(b)\n            dfs(i+1, curr)\n            curr.pop()\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_palindrome_partitions(s):\n    res = []\n    def dfs(start, path):\n        if start == len(s):\n            res.append(path[:]); return\n        for end in range(start+1, len(s)+1):\n            substr = s[start:end]\n            if substr == substr[::-1]:\n                dfs(end, path+[substr])\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def gray_code(n):\n    if n == 0:\n        return ['']\n    first = gray_code(n-1)\n    return ['0'+code for code in first] + ['1'+code for code in reversed(first)]" },
    { "complexity": "O(2^n)", "code": "def all_subset_sums(lst):\n    res = set()\n    def backtrack(i, acc):\n        if i == len(lst):\n            res.add(acc); return\n        backtrack(i+1, acc)\n        backtrack(i+1, acc+lst[i])\n    backtrack(0, 0)\n    return list(res)" },
    { "complexity": "O(2^n)", "code": "def all_string_masks(s):\n    res = []\n    n = len(s)\n    for i in range(1<<n):\n        mask = ''\n        for j in range(n):\n            if i & (1<<j):\n                mask += s[j]\n        res.append(mask)\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_combinations_binary(n):\n    res = []\n    def dfs(i, curr):\n        if i == n:\n            res.append(''.join(map(str, curr))); return\n        for b in [0, 1]:\n            curr.append(b)\n            dfs(i+1, curr)\n            curr.pop()\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def count_ways_staircase(n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    return count_ways_staircase(n-1) + count_ways_staircase(n-2)" },
    { "complexity": "O(2^n)", "code": "def all_k_length_binary(n, k):\n    res = []\n    def dfs(i, curr):\n        if len(curr) == k:\n            res.append(''.join(map(str, curr))); return\n        for b in [0, 1]:\n            dfs(i+1, curr+[b])\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_possible_coin_change(coins, amount):\n    res = []\n    def dfs(i, curr, total):\n        if total == amount:\n            res.append(curr[:]); return\n        if total > amount or i == len(coins):\n            return\n        dfs(i, curr+[coins[i]], total+coins[i])\n        dfs(i+1, curr, total)\n    dfs(0, [], 0)\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_bit_flips(n):\n    res = []\n    def dfs(i, curr):\n        if i == n:\n            res.append(curr[:]); return\n        for b in [0, 1]:\n            curr.append(b)\n            dfs(i+1, curr)\n            curr.pop()\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_unique_combinations(nums):\n    res = set()\n    def dfs(i, curr):\n        if i == len(nums):\n            res.add(tuple(sorted(curr))); return\n        dfs(i+1, curr)\n        dfs(i+1, curr+[nums[i]])\n    dfs(0, [])\n    return [list(x) for x in res]" },
    { "complexity": "O(2^n)", "code": "def all_ways_partition(nums):\n    res = []\n    def dfs(i, curr1, curr2):\n        if i == len(nums):\n            res.append((curr1[:], curr2[:])); return\n        curr1.append(nums[i])\n        dfs(i+1, curr1, curr2)\n        curr1.pop()\n        curr2.append(nums[i])\n        dfs(i+1, curr1, curr2)\n        curr2.pop()\n    dfs(0, [], [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_possible_signs(nums):\n    res = []\n    def dfs(i, curr):\n        if i == len(nums):\n            res.append(curr[:]); return\n        dfs(i+1, curr+[nums[i]])\n        dfs(i+1, curr+[-nums[i]])\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_string_partitions(s):\n    res = []\n    def dfs(i, curr):\n        if i == len(s):\n            res.append(curr[:]); return\n        for j in range(i+1, len(s)+1):\n            dfs(j, curr+[s[i:j]])\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_paths_in_grid(n, m):\n    res = []\n    def dfs(i, j, path):\n        if i == n-1 and j == m-1:\n            res.append(path[:]); return\n        if i+1 < n: dfs(i+1, j, path+['D'])\n        if j+1 < m: dfs(i, j+1, path+['R'])\n    dfs(0, 0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_ways_sum(nums, target):\n    res = []\n    def dfs(i, curr, total):\n        if total == target:\n            res.append(curr[:]); return\n        if i == len(nums):\n            return\n        dfs(i+1, curr+[nums[i]], total+nums[i])\n        dfs(i+1, curr, total)\n    dfs(0, [], 0)\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_string_case_combinations(s):\n    res = ['']\n    for c in s:\n        if c.isalpha():\n            res = [r + ch for r in res for ch in [c.lower(), c.upper()]]\n        else:\n            res = [r + c for r in res]\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_k_length_permutations(lst, k):\n    if k == 0:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for p in all_k_length_permutations(lst[:i]+lst[i+1:], k-1):\n            res.append([lst[i]]+p)\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_possible_bracketings(s):\n    if len(s) == 1:\n        return [s]\n    res = []\n    for i in range(1, len(s), 2):\n        left = all_possible_bracketings(s[:i])\n        right = all_possible_bracketings(s[i+1:])\n        for l in left:\n            for r in right:\n                res.append('(' + l + s[i] + r + ')')\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_subsets_with_sum(nums, target):\n    res = []\n    def dfs(i, curr, total):\n        if i == len(nums):\n            if total == target:\n                res.append(curr[:])\n            return\n        dfs(i+1, curr+[nums[i]], total+nums[i])\n        dfs(i+1, curr, total)\n    dfs(0, [], 0)\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_palindromic_partitions(s):\n    res = []\n    def dfs(start, path):\n        if start == len(s):\n            res.append(path[:]); return\n        for end in range(start+1, len(s)+1):\n            substr = s[start:end]\n            if substr == substr[::-1]:\n                dfs(end, path+[substr])\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_k_combinations(nums, k):\n    res = []\n    def dfs(i, curr):\n        if len(curr) == k:\n            res.append(curr[:]); return\n        if i == len(nums):\n            return\n        dfs(i+1, curr+[nums[i]])\n        dfs(i+1, curr)\n    dfs(0, [])\n    return res" },
    { "complexity": "O(2^n)", "code": "def all_boolean_evaluations(expr):\n    if len(expr) == 1:\n        return [expr]\n    res = []\n    for i in range(1, len(expr), 2):\n        left = all_boolean_evaluations(expr[:i])\n        right = all_boolean_evaluations(expr[i+1:])\n        for l in left:\n            for r in right:\n                res.append('(' + l + expr[i] + r + ')')\n    return res" }
  ,{"code": "def sum_cubes(arr):\n    total = 0\n    for i in arr:\n        for j in arr:\n            for k in arr:\n                total += i + j + k\n    return total", "complexity": "O(n^3)"},
    {"code": "def count_triples(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            for k in range(j, len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    count += 1\n    return count", "complexity": "O(n^3)"},
    {"code": "def max_triplet(arr):\n    mx = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                mx = max(mx, arr[i]+arr[j]+arr[k])\n    return mx", "complexity": "O(n^3)"},
    {"code": "def product_triples(a):\n    result = 1\n    for i in a:\n        for j in a:\n            for k in a:\n                result *= (i or 1) * (j or 1) * (k or 1)\n    return result", "complexity": "O(n^3)"},
    {"code": "def triple_if(n):\n    cnt = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for k in range(n):\n                    if k > i:\n                        cnt += 1\n    return cnt", "complexity": "O(n^3)"},
    {"code": "def three_level_break(n):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i + j + k == 0:\n                    break", "complexity": "O(n^3)"},
    {"code": "def cube_indices(mat):\n    for i in range(len(mat)):\n        for j in range(len(mat)):\n            for k in range(len(mat)):\n                mat[i][j] = mat[j][k] + mat[k][i]", "complexity": "O(n^3)"},
    {"code": "def test_triplets(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                a.append(i + j + k)\n    return a", "complexity": "O(n^3)"},
    {"code": "def combinations3(lst):\n    for a in lst:\n        for b in lst:\n            for c in lst:\n                print(a, b, c)", "complexity": "O(n^3)"},
    {"code": "def triple_nested_fancy(a):\n    for i in range(len(a)):\n        for j in range(i):\n            for k in range(j):\n                print(a[i], a[j], a[k])", "complexity": "O(n^3)"},
    {"code": "def sum_of_triplets(arr):\n    s = 0\n    for i in arr:\n        for j in arr:\n            for k in arr:\n                s += i + j + k\n    return s", "complexity": "O(n^3)"},
    {"code": "def find_triplets(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                if a[i] + a[j] + a[k] > 0:\n                    print(a[i], a[j], a[k])", "complexity": "O(n^3)"},
    {"code": "def triple_for_func(n):\n    def f(x): return x+1\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                f(i+j+k)", "complexity": "O(n^3)"},
    {"code": "def three_indexed(lst):\n    for i, a in enumerate(lst):\n        for j, b in enumerate(lst):\n            for k, c in enumerate(lst):\n                lst[i] = a + b + c", "complexity": "O(n^3)"},
    {"code": "def all_triplets_unique(lst):\n    for i in range(len(lst)):\n        for j in range(len(lst)):\n            for k in range(len(lst)):\n                if i < j < k:\n                    print(lst[i], lst[j], lst[k])", "complexity": "O(n^3)"},
    {"code": "def cube_sum2(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                a[i] = a[j] + a[k]", "complexity": "O(n^3)"},
    {"code": "def triple_nested_with_func(a):\n    def helper(x, y, z):\n        return x*y*z\n    for i in a:\n        for j in a:\n            for k in a:\n                helper(i, j, k)", "complexity": "O(n^3)"},
    {"code": "def three_dim_matrix(n):\n    cube = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                cube[i][j][k] = i + j + k", "complexity": "O(n^3)"},
    {"code": "def three_loops_conditional(n):\n    cnt = 0\n    for i in range(n):\n        if i % 2 == 0:\n            for j in range(n):\n                for k in range(n):\n                    cnt += 1\n    return cnt", "complexity": "O(n^3)"},
    {"code": "def triple_sum_matrix(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                a[i][j] += a[j][k]", "complexity": "O(n^3)"},
    {"code": "def count_all_triplets(a):\n    cnt = 0\n    for i in a:\n        for j in a:\n            for k in a:\n                cnt += 1\n    return cnt", "complexity": "O(n^3)"},
    {"code": "def three_for_with_break(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                if k == 0:\n                    break", "complexity": "O(n^3)"},
    {"code": "def three_level_continue(lst):\n    for i in lst:\n        for j in lst:\n            for k in lst:\n                if i == j:\n                    continue", "complexity": "O(n^3)"},
    {"code": "def triple_and_return(arr):\n    for i in arr:\n        for j in arr:\n            for k in arr:\n                if i + j + k == 10:\n                    return True\n    return False", "complexity": "O(n^3)"},
    {"code": "def triple_for_assign(n):\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                result = i * j * k\n    return result", "complexity": "O(n^3)"},
    {"code": "def three_nested_lists(a):\n    for x in a:\n        for y in a:\n            for z in a:\n                print(x, y, z)", "complexity": "O(n^3)"},
    {"code": "def triple_sum_list(lst):\n    total = 0\n    for i in lst:\n        for j in lst:\n            for k in lst:\n                total += i*j*k\n    return total", "complexity": "O(n^3)"},
    {"code": "def triple_index_sum(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                a[i] = j + k", "complexity": "O(n^3)"},
    {"code": "def three_dimensional_array(n):\n    arr = [[[0]*n]*n]*n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                arr[i][j][k] = i*j*k", "complexity": "O(n^3)"},
    {"code": "def triple_nested_lambda(n):\n    f = lambda x: x + 1\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                f(i + j + k)", "complexity": "O(n^3)"},
    {"code": "def all_triplets(arr):\n    for i in arr:\n        for j in arr:\n            for k in arr:\n                yield (i, j, k)", "complexity": "O(n^3)"},
    {"code": "def find_sum_triplets(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                x = a[i] + a[j] + a[k]", "complexity": "O(n^3)"},
    {"code": "def multiply_triplets(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                a.append(i * j * k)\n    return a", "complexity": "O(n^3)"},
    {"code": "def three_for_return(n):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i * j * k == 0:\n                    return True\n    return False", "complexity": "O(n^3)"},
    {"code": "def three_level_sum(a):\n    s = 0\n    for i in a:\n        for j in a:\n            for k in a:\n                s += i + j + k\n    return s", "complexity": "O(n^3)"},
    {"code": "def triple_if_continue(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                if i == k:\n                    continue", "complexity": "O(n^3)"},
    {"code": "def three_nested_and_func(lst):\n    def inc(x): return x+1\n    for i in lst:\n        for j in lst:\n            for k in lst:\n                inc(i+j+k)", "complexity": "O(n^3)"},
    {"code": "def three_for_print(n):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                print(i, j, k)", "complexity": "O(n^3)"},
    {"code": "def count_triplets2(a):\n    cnt = 0\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                cnt += 1\n    return cnt", "complexity": "O(n^3)"},
    {"code": "def three_level_assign(lst):\n    for i in lst:\n        for j in lst:\n            for k in lst:\n                lst[0] = i + j + k", "complexity": "O(n^3)"},
    {"code": "def three_for_sum(a):\n    s = 0\n    for i in a:\n        for j in a:\n            for k in a:\n                s += i * j * k\n    return s", "complexity": "O(n^3)"},
    {"code": "def three_nested_yield(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                yield i + j + k", "complexity": "O(n^3)"},
    {"code": "def three_for_conditional(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                if i + j > k:\n                    pass", "complexity": "O(n^3)"},
    {"code": "def triple_for_update(lst):\n    for i in lst:\n        for j in lst:\n            for k in lst:\n                lst[-1] = i + j + k", "complexity": "O(n^3)"},
    {"code": "def three_loop_nested_func(a):\n    def helper(i, j, k):\n        return i * j * k\n    for i in a:\n        for j in a:\n            for k in a:\n                helper(i, j, k)", "complexity": "O(n^3)"},
    {"code": "def all_triplet_combos(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                print(i, j, k)", "complexity": "O(n^3)"},
    {"code": "def triple_nested_index(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                a[k] = i + j", "complexity": "O(n^3)"},
    {"code": "def three_layered_break(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                if i == j:\n                    break", "complexity": "O(n^3)"},
    {"code": "def triple_assignment(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                a[0] = i * j * k", "complexity": "O(n^3)"},
      {"code": "def triple_sum(arr):\n    total = 0\n    for i in arr:\n        for j in arr:\n            for k in arr:\n                total += i + j + k\n    return total", "complexity": "O(n^3)"},
    {"code": "def count_triplets(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            for k in range(len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    count += 1\n    return count", "complexity": "O(n^3)"},
    {"code": "def all_triplets_unique(lst):\n    for i in range(len(lst)):\n        for j in range(len(lst)):\n            for k in range(len(lst)):\n                if i < j < k:\n                    print(lst[i], lst[j], lst[k])", "complexity": "O(n^3)"},
    {"code": "def max_triplet(arr):\n    mx = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                mx = max(mx, arr[i]+arr[j]+arr[k])\n    return mx", "complexity": "O(n^3)"},
    {"code": "def matrix_cube_sum(mat):\n    s = 0\n    size = len(mat)\n    for i in range(size):\n        for j in range(size):\n            for k in range(size):\n                s += mat[i][j] * mat[j][k] * mat[k][i]\n    return s", "complexity": "O(n^3)"},
    {"code": "def triple_nested_if(n):\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for k in range(n):\n                    print(i, j, k)", "complexity": "O(n^3)"},
    {"code": "def find_sum_triplets(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                x = a[i] + a[j] + a[k]", "complexity": "O(n^3)"},
    {"code": "def triple_for_func(n):\n    def f(x): return x+1\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                f(i+j+k)", "complexity": "O(n^3)"},
    {"code": "def three_dim_matrix(n):\n    cube = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                cube[i][j][k] = i + j + k", "complexity": "O(n^3)"},
    {"code": "def triple_index_sum(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                a[i] = j + k", "complexity": "O(n^3)"},
   {"code": "def permutations(lst):\n    if not lst:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for p in permutations(lst[:i]+lst[i+1:]):\n            res.append([lst[i]]+p)\n    return res", "complexity": "O(n!)"},
    {"code": "def string_perms(s):\n    if len(s) == 0:\n        return ['']\n    perms = []\n    for i in range(len(s)):\n        for p in string_perms(s[:i] + s[i+1:]):\n            perms.append(s[i] + p)\n    return perms", "complexity": "O(n!)"},
    {"code": "import itertools\ndef all_perms(lst):\n    return list(itertools.permutations(lst))", "complexity": "O(n!)"},
    {"code": "def permute_unique(nums):\n    if len(nums) == 0:\n        return [[]]\n    perms = []\n    used = set()\n    for i in range(len(nums)):\n        if nums[i] in used:\n            continue\n        used.add(nums[i])\n        for p in permute_unique(nums[:i]+nums[i+1:]):\n            perms.append([nums[i]]+p)\n    return perms", "complexity": "O(n!)"},
    {"code": "def recursive_perms(a, path=[]):\n    if not a:\n        print(path)\n    else:\n        for i in range(len(a)):\n            recursive_perms(a[:i] + a[i+1:], path + [a[i]])", "complexity": "O(n!)"},
    {"code": "def seating(people):\n    if not people:\n        return [[]]\n    result = []\n    for i, p in enumerate(people):\n        for rest in seating(people[:i]+people[i+1:]):\n            result.append([p]+rest)\n    return result", "complexity": "O(n!)"},
    {"code": "def factorial_permutations(s):\n    if not s:\n        return ['']\n    result = []\n    for i, char in enumerate(s):\n        for perm in factorial_permutations(s[:i]+s[i+1:]):\n            result.append(char+perm)\n    return result", "complexity": "O(n!)"},
    {"code": "def permute_dict_keys(d):\n    keys = list(d.keys())\n    return all_perms(keys)", "complexity": "O(n!)"},
    {"code": "def get_perms(l):\n    if not l:\n        return [[]]\n    out = []\n    for i in range(len(l)):\n        for p in get_perms(l[:i]+l[i+1:]):\n            out.append([l[i]]+p)\n    return out", "complexity": "O(n!)"},
    {"code": "def permute_with_prefix(arr, prefix=[]):\n    if len(arr) == 0:\n        print(prefix)\n    for i in range(len(arr)):\n        permute_with_prefix(arr[:i]+arr[i+1:], prefix + [arr[i]])", "complexity": "O(n!)"},
    {"code": "def seating_perms(guests):\n    if not guests:\n        return [[]]\n    res = []\n    for i in range(len(guests)):\n        for p in seating_perms(guests[:i]+guests[i+1:]):\n            res.append([guests[i]]+p)\n    return res", "complexity": "O(n!)"},
    {"code": "def all_anagrams(word):\n    if len(word) <= 1:\n        return [word]\n    anags = []\n    for i, c in enumerate(word):\n        for a in all_anagrams(word[:i]+word[i+1:]):\n            anags.append(c+a)\n    return anags", "complexity": "O(n!)"},
    {"code": "def permute_numbers(nums):\n    if not nums:\n        return [[]]\n    output = []\n    for i in range(len(nums)):\n        for p in permute_numbers(nums[:i]+nums[i+1:]):\n            output.append([nums[i]]+p)\n    return output", "complexity": "O(n!)"},
    {"code": "def permute_and_print(arr, path=[]):\n    if not arr:\n        print(path)\n        return\n    for i in range(len(arr)):\n        permute_and_print(arr[:i]+arr[i+1:], path+[arr[i]])", "complexity": "O(n!)"},
    {"code": "def perms(x):\n    if len(x) == 1:\n        return [x]\n    out = []\n    for i in range(len(x)):\n        for p in perms(x[:i] + x[i+1:]):\n            out.append([x[i]] + p)\n    return out", "complexity": "O(n!)"},
    {"code": "def permutation_helper(s, prefix=''):\n    if len(s) == 0:\n        print(prefix)\n    else:\n        for i in range(len(s)):\n            permutation_helper(s[:i]+s[i+1:], prefix+s[i])", "complexity": "O(n!)"},
    {"code": "def generate_combinations(arr):\n    if len(arr) == 0:\n        return [[]]\n    result = []\n    for i in range(len(arr)):\n        for c in generate_combinations(arr[:i]+arr[i+1:]):\n            result.append([arr[i]]+c)\n    return result", "complexity": "O(n!)"},
    {"code": "def getperm(lst):\n    if not lst:\n        return [[]]\n    output = []\n    for i in range(len(lst)):\n        rest = lst[:i]+lst[i+1:]\n        for p in getperm(rest):\n            output.append([lst[i]]+p)\n    return output", "complexity": "O(n!)"},
    {"code": "def all_permutations(lst):\n    if len(lst) == 0:\n        return [[]]\n    perms = []\n    for i in range(len(lst)):\n        for p in all_permutations(lst[:i]+lst[i+1:]):\n            perms.append([lst[i]]+p)\n    return perms", "complexity": "O(n!)"},
    {"code": "def permute2(lst):\n    if len(lst) == 0:\n        return [[]]\n    result = []\n    for i, x in enumerate(lst):\n        for p in permute2(lst[:i]+lst[i+1:]):\n            result.append([x]+p)\n    return result", "complexity": "O(n!)"},
    {"code": "def permute_with_flag(arr, used=None, path=[]):\n    if used is None:\n        used = [False]*len(arr)\n    if len(path) == len(arr):\n        print(path)\n        return\n    for i in range(len(arr)):\n        if not used[i]:\n            used[i] = True\n            permute_with_flag(arr, used, path+[arr[i]])\n            used[i] = False", "complexity": "O(n!)"},
    {"code": "def generate_all_permutations(lst):\n    if not lst:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for p in generate_all_permutations(lst[:i]+lst[i+1:]):\n            res.append([lst[i]]+p)\n    return res", "complexity": "O(n!)"},
    {"code": "def permute_str(s):\n    if len(s) == 0:\n        return ['']\n    result = []\n    for i in range(len(s)):\n        for p in permute_str(s[:i]+s[i+1:]):\n            result.append(s[i]+p)\n    return result", "complexity": "O(n!)"},
    {"code": "def all_permute(arr):\n    if len(arr) == 0:\n        return [[]]\n    perms = []\n    for i in range(len(arr)):\n        for p in all_permute(arr[:i]+arr[i+1:]):\n            perms.append([arr[i]]+p)\n    return perms", "complexity": "O(n!)"},
    {"code": "def power_set(arr):\n    if not arr:\n        return [[]]\n    first = arr[0]\n    rest = power_set(arr[1:])\n    return rest + [[first] + x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)", "complexity": "O(2^n)"},
    {"code": "def subset_sum(arr, target):\n    if target == 0:\n        return True\n    if not arr:\n        return False\n    return subset_sum(arr[1:], target) or subset_sum(arr[1:], target-arr[0])", "complexity": "O(2^n)"},
    {"code": "def count_ways(n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    return count_ways(n-1) + count_ways(n-2)", "complexity": "O(2^n)"},
    {"code": "def generate_strings(s):\n    if not s:\n        return ['']\n    rest = generate_strings(s[1:])\n    return rest + [s[0]+x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def all_subsets(arr):\n    res = [[]]\n    for x in arr:\n        res += [curr + [x] for curr in res]\n    return res", "complexity": "O(2^n)"},
    {"code": "def all_binary(n):\n    if n == 0:\n        return ['']\n    return ['0'+x for x in all_binary(n-1)] + ['1'+x for x in all_binary(n-1)]", "complexity": "O(2^n)"},
    {"code": "def ways_to_climb(n):\n    if n <= 1:\n        return 1\n    return ways_to_climb(n-1) + ways_to_climb(n-2)", "complexity": "O(2^n)"},
    {"code": "def sum_subsets(arr):\n    if not arr:\n        return [0]\n    rest = sum_subsets(arr[1:])\n    return rest + [arr[0] + x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def all_paths(n):\n    if n == 0:\n        return 1\n    return all_paths(n-1) + all_paths(n-1)", "complexity": "O(2^n)"},
     {"code": "def permute(arr):\n    if len(arr) <= 1:\n        return [arr]\n    result = []\n    for i in range(len(arr)):\n        rest = arr[:i] + arr[i+1:]\n        for p in permute(rest):\n            result.append([arr[i]] + p)\n    return result", "complexity": "O(n!)"},
    {"code": "import itertools\ndef all_perms(lst):\n    return list(itertools.permutations(lst))", "complexity": "O(n!)"},
    {"code": "def seating(people):\n    if not people:\n        return [[]]\n    result = []\n    for i, p in enumerate(people):\n        for rest in seating(people[:i]+people[i+1:]):\n            result.append([p]+rest)\n    return result", "complexity": "O(n!)"},
    {"code": "def string_perms(s):\n    if len(s) == 0:\n        return ['']\n    perms = []\n    for i in range(len(s)):\n        for p in string_perms(s[:i] + s[i+1:]):\n            perms.append(s[i] + p)\n    return perms", "complexity": "O(n!)"},
    {"code": "def permute_unique(nums):\n    if len(nums) == 0:\n        return [[]]\n    perms = []\n    used = set()\n    for i in range(len(nums)):\n        if nums[i] in used:\n            continue\n        used.add(nums[i])\n        for p in permute_unique(nums[:i]+nums[i+1:]):\n            perms.append([nums[i]]+p)\n    return perms", "complexity": "O(n!)"},
    {"code": "def fact_perm(a, path=[]):\n    if len(a) == 0:\n        print(path)\n    else:\n        for i in range(len(a)):\n            fact_perm(a[:i]+a[i+1:], path+[a[i]])", "complexity": "O(n!)"},
    {"code": "def all_anagrams(word):\n    if len(word) <= 1:\n        return [word]\n    anags = []\n    for i, c in enumerate(word):\n        for a in all_anagrams(word[:i]+word[i+1:]):\n            anags.append(c+a)\n    return anags", "complexity": "O(n!)"},
    {"code": "def permute_numbers(nums):\n    if not nums:\n        return [[]]\n    output = []\n    for i in range(len(nums)):\n        for p in permute_numbers(nums[:i]+nums[i+1:]):\n            output.append([nums[i]]+p)\n    return output", "complexity": "O(n!)"},
    {"code": "def permute_with_flag(arr, used=None, path=[]):\n    if used is None:\n        used = [False]*len(arr)\n    if len(path) == len(arr):\n        print(path)\n        return\n    for i in range(len(arr)):\n        if not used[i]:\n            used[i] = True\n            permute_with_flag(arr, used, path+[arr[i]])\n            used[i] = False", "complexity": "O(n!)"},
    {"code": "def generate_all_permutations(lst):\n    if not lst:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for p in generate_all_permutations(lst[:i]+lst[i+1:]):\n            res.append([lst[i]]+p)\n    return res", "complexity": "O(n!)"},
    {"code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr)//2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\ndef merge(a, b):\n    result = []\n    while a and b:\n        if a[0] < b[0]: result.append(a.pop(0))\n        else: result.append(b.pop(0))\n    result += a + b\n    return result", "complexity": "O(n log n)"},
    {"code": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[0]\n    less = [x for x in arr[1:] if x < pivot]\n    greater = [x for x in arr[1:] if x >= pivot]\n    return quick_sort(less) + [pivot] + quick_sort(greater)", "complexity": "O(n log n)"},
    {"code": "def tim_sort(a):\n    a.sort()\n    return a", "complexity": "O(n log n)"},
    {"code": "def heapsort(arr):\n    import heapq\n    h = []\n    for val in arr:\n        heapq.heappush(h, val)\n    return [heapq.heappop(h) for _ in range(len(arr))]", "complexity": "O(n log n)"},
    {"code": "def sort_unique(lst):\n    return sorted(set(lst))", "complexity": "O(n log n)"},
    {"code": "def sort_reverse(a):\n    return sorted(a, reverse=True)", "complexity": "O(n log n)"},
    {"code": "def index_sort(a):\n    return sorted((x, i) for i, x in enumerate(a))", "complexity": "O(n log n)"},
    {"code": "def sort_by_length(lst):\n    return sorted(lst, key=len)", "complexity": "O(n log n)"},
    {"code": "def sort_with_lambda(a):\n    return sorted(a, key=lambda x: x % 10)", "complexity": "O(n log n)"},
    {"code": "def stable_sort(a):\n    return sorted(a, key=str)", "complexity": "O(n log n)"},
        {"code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr", "complexity": "O(n^2)"},
    {"code": "def selection_sort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr", "complexity": "O(n^2)"},
    {"code": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j >= 0 and key < arr[j]:\n            arr[j+1] = arr[j]\n            j -= 1\n        arr[j+1] = key\n    return arr", "complexity": "O(n^2)"},
    {"code": "def all_pairs(a):\n    pairs = []\n    for i in a:\n        for j in a:\n            pairs.append((i, j))\n    return pairs", "complexity": "O(n^2)"},
    {"code": "def unique_pairs(lst):\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            pairs.append((lst[i], lst[j]))\n    return pairs", "complexity": "O(n^2)"},
    {"code": "def duplicate_count(arr):\n    cnt = 0\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j and arr[i] == arr[j]:\n                cnt += 1\n    return cnt // 2", "complexity": "O(n^2)"},
    {"code": "def is_substring(a, b):\n    for i in range(len(a) - len(b) + 1):\n        for j in range(len(b)):\n            if a[i+j] != b[j]:\n                break\n        else:\n            return True\n    return False", "complexity": "O(n^2)"},
    {"code": "def find_duplicates(a):\n    dups = []\n    for i in range(len(a)):\n        for j in range(i+1, len(a)):\n            if a[i] == a[j]:\n                dups.append(a[i])\n    return dups", "complexity": "O(n^2)"},
    {"code": "def nested_sum(a):\n    s = 0\n    for i in a:\n        for j in a:\n            s += i + j\n    return s", "complexity": "O(n^2)"},
    {"code": "def all_pairs_matrix(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = i + j", "complexity": "O(n^2)"},
     {"code": "def triple_sum(arr):\n    total = 0\n    for i in arr:\n        for j in arr:\n            for k in arr:\n                total += i + j + k\n    return total", "complexity": "O(n^3)"},
    {"code": "def count_triplets(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            for k in range(len(arr)):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    count += 1\n    return count", "complexity": "O(n^3)"},
    {"code": "def all_triplets_unique(lst):\n    for i in range(len(lst)):\n        for j in range(len(lst)):\n            for k in range(len(lst)):\n                if i < j < k:\n                    print(lst[i], lst[j], lst[k])", "complexity": "O(n^3)"},
    {"code": "def max_triplet(arr):\n    mx = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                mx = max(mx, arr[i]+arr[j]+arr[k])\n    return mx", "complexity": "O(n^3)"},
    {"code": "def matrix_cube_sum(mat):\n    s = 0\n    size = len(mat)\n    for i in range(size):\n        for j in range(size):\n            for k in range(size):\n                s += mat[i][j] * mat[j][k] * mat[k][i]\n    return s", "complexity": "O(n^3)"},
    {"code": "def triple_nested_if(n):\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for k in range(n):\n                    print(i, j, k)", "complexity": "O(n^3)"},
    {"code": "def find_sum_triplets(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                x = a[i] + a[j] + a[k]", "complexity": "O(n^3)"},
    {"code": "def triple_for_func(n):\n    def f(x): return x+1\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                f(i+j+k)", "complexity": "O(n^3)"},
    {"code": "def three_dim_matrix(n):\n    cube = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                cube[i][j][k] = i + j + k", "complexity": "O(n^3)"},
    {"code": "def triple_index_sum(a):\n    for i in range(len(a)):\n        for j in range(len(a)):\n            for k in range(len(a)):\n                a[i] = j + k", "complexity": "O(n^3)"},
     {"code": "def power_set(arr):\n    if not arr:\n        return [[]]\n    first = arr[0]\n    rest = power_set(arr[1:])\n    return rest + [[first] + x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)", "complexity": "O(2^n)"},
    {"code": "def subset_sum(arr, target):\n    if target == 0:\n        return True\n    if not arr:\n        return False\n    return subset_sum(arr[1:], target) or subset_sum(arr[1:], target-arr[0])", "complexity": "O(2^n)"},
    {"code": "def count_ways(n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    return count_ways(n-1) + count_ways(n-2)", "complexity": "O(2^n)"},
    {"code": "def generate_strings(s):\n    if not s:\n        return ['']\n    rest = generate_strings(s[1:])\n    return rest + [s[0]+x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def all_subsets(arr):\n    res = [[]]\n    for x in arr:\n        res += [curr + [x] for curr in res]\n    return res", "complexity": "O(2^n)"},
    {"code": "def all_binary(n):\n    if n == 0:\n        return ['']\n    return ['0'+x for x in all_binary(n-1)] + ['1'+x for x in all_binary(n-1)]", "complexity": "O(2^n)"},
    {"code": "def ways_to_climb(n):\n    if n <= 1:\n        return 1\n    return ways_to_climb(n-1) + ways_to_climb(n-2)", "complexity": "O(2^n)"},
    {"code": "def sum_subsets(arr):\n    if not arr:\n        return [0]\n    rest = sum_subsets(arr[1:])\n    return rest + [arr[0] + x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def all_paths(n):\n    if n == 0:\n        return 1\n    return all_paths(n-1) + all_paths(n-1)", "complexity": "O(2^n)"},   {"code": "def permute(arr):\n    if len(arr) <= 1:\n        return [arr]\n    result = []\n    for i in range(len(arr)):\n        rest = arr[:i] + arr[i+1:]\n        for p in permute(rest):\n            result.append([arr[i]] + p)\n    return result", "complexity": "O(n!)"},
    {"code": "import itertools\ndef all_perms(lst):\n    return list(itertools.permutations(lst))", "complexity": "O(n!)"},
    {"code": "def seating(people):\n    if not people:\n        return [[]]\n    result = []\n    for i, p in enumerate(people):\n        for rest in seating(people[:i]+people[i+1:]):\n            result.append([p]+rest)\n    return result", "complexity": "O(n!)"},
    {"code": "def string_perms(s):\n    if len(s) == 0:\n        return ['']\n    perms = []\n    for i in range(len(s)):\n        for p in string_perms(s[:i] + s[i+1:]):\n            perms.append(s[i] + p)\n    return perms", "complexity": "O(n!)"},
    {"code": "def permute_unique(nums):\n    if len(nums) == 0:\n        return [[]]\n    perms = []\n    used = set()\n    for i in range(len(nums)):\n        if nums[i] in used:\n            continue\n        used.add(nums[i])\n        for p in permute_unique(nums[:i]+nums[i+1:]):\n            perms.append([nums[i]]+p)\n    return perms", "complexity": "O(n!)"},
    {"code": "def fact_perm(a, path=[]):\n    if len(a) == 0:\n        print(path)\n    else:\n        for i in range(len(a)):\n            fact_perm(a[:i]+a[i+1:], path+[a[i]])", "complexity": "O(n!)"},
    {"code": "def all_anagrams(word):\n    if len(word) <= 1:\n        return [word]\n    anags = []\n    for i, c in enumerate(word):\n        for a in all_anagrams(word[:i]+word[i+1:]):\n            anags.append(c+a)\n    return anags", "complexity": "O(n!)"},
    {"code": "def permute_numbers(nums):\n    if not nums:\n        return [[]]\n    output = []\n    for i in range(len(nums)):\n        for p in permute_numbers(nums[:i]+nums[i+1:]):\n            output.append([nums[i]]+p)\n    return output", "complexity": "O(n!)"},
    {"code": "def permute_with_flag(arr, used=None, path=[]):\n    if used is None:\n        used = [False]*len(arr)\n    if len(path) == len(arr):\n        print(path)\n        return\n    for i in range(len(arr)):\n        if not used[i]:\n            used[i] = True\n            permute_with_flag(arr, used, path+[arr[i]])\n            used[i] = False", "complexity": "O(n!)"},
    {"code": "def generate_all_permutations(lst):\n    if not lst:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for p in generate_all_permutations(lst[:i]+lst[i+1:]):\n            res.append([lst[i]]+p)\n    return res", "complexity": "O(n!)"},
     {"code": "def pair_sum_brute(a):\n    i = 0\n    while i < len(a):\n        for j in range(len(a)):\n            print(a[i]+a[j])\n        i += 1", "complexity": "O(n^2)"},
    {"code": "def nested_two_diff(a, b):\n    for i in a:\n        for j in b:\n            print(i, j)", "complexity": "O(n^2)"},
    {"code": "def print_matrix_diag(mat):\n    for i in range(len(mat)):\n        j = 0\n        while j < len(mat[i]):\n            if i == j:\n                print(mat[i][j])\n            j += 1", "complexity": "O(n^2)"},
    {"code": "def two_loops_func(a):\n    def inner(x): return x*x\n    for i in a:\n        for j in a:\n            inner(i+j)", "complexity": "O(n^2)"},
    {"code": "def quadratic_accumulate(n):\n    s = 0\n    i = 0\n    while i < n:\n        for j in range(n):\n            s += i*j\n        i += 1\n    return s", "complexity": "O(n^2)"},
  {"code": "def triple_nested_while(n):\n    i=0\n    while i<n:\n        j=0\n        while j<n:\n            for k in range(n):\n                print(i, j, k)\n            j += 1\n        i += 1", "complexity": "O(n^3)"},
    {"code": "def three_lists(a, b, c):\n    for x in a:\n        for y in b:\n            for z in c:\n                print(x, y, z)", "complexity": "O(n^3)"},
    {"code": "def deep_nested(a):\n    def helper(x): return x+1\n    for i in a:\n        for j in a:\n            for k in a:\n                helper(i+j+k)", "complexity": "O(n^3)"},
    {"code": "def cube_sum_while(a):\n    i = 0\n    while i < len(a):\n        j = 0\n        while j < len(a):\n            k = 0\n            while k < len(a):\n                print(a[i]+a[j]+a[k])\n                k += 1\n            j += 1\n        i += 1", "complexity": "O(n^3)"},
    {"code": "def triple_nested_cond(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                if (i+j)%2 == 0:\n                    print(i, j, k)", "complexity": "O(n^3)"},
     {"code": "def custom_sort(arr):\n    arr.sort(key=lambda x: -x)\n    return arr", "complexity": "O(n log n)"},
    {"code": "def sort_and_filter(a):\n    b = sorted(a)\n    return [x for x in b if x > 0]", "complexity": "O(n log n)"},
    {"code": "def log_linear_merge(a, b):\n    c = sorted(a + b)\n    return c", "complexity": "O(n log n)"},
    {"code": "def max_heapify_all(a):\n    import heapq\n    heapq.heapify(a)\n    return [heapq.heappop(a) for _ in range(len(a))]", "complexity": "O(n log n)"},
    {"code": "def nlogn_with_for(n):\n    arr = list(range(n))\n    arr.sort()\n    for i in range(n):\n        arr[i] += 1\n    return arr", "complexity": "O(n log n)"},
     {"code": "def all_combinations(bits):\n    if bits == 0:\n        return ['']\n    rest = all_combinations(bits-1)\n    return ['0'+x for x in rest] + ['1'+x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def recursive_split(s):\n    if not s:\n        return ['']\n    part1 = recursive_split(s[1:])\n    part2 = recursive_split(s[1:])\n    return part1 + part2", "complexity": "O(2^n)"},
    {"code": "def combinations(arr):\n    if not arr:\n        return [[]]\n    tail = combinations(arr[1:])\n    return tail + [[arr[0]] + x for x in tail]", "complexity": "O(2^n)"},
    {"code": "def count_binary_strings(n):\n    if n == 0:\n        return 1\n    return count_binary_strings(n-1) + count_binary_strings(n-1)", "complexity": "O(2^n)"},
    {"code": "def all_subsequences(a):\n    if not a:\n        return [[]]\n    rest = all_subsequences(a[1:])\n    return rest + [[a[0]] + x for x in rest]", "complexity": "O(2^n)"},
      {"code": "def all_orderings(lst):\n    if not lst:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for perm in all_orderings(lst[:i]+lst[i+1:]):\n            res.append([lst[i]]+perm)\n    return res", "complexity": "O(n!)"},
    {"code": "def perms_while(lst):\n    if not lst:\n        return [[]]\n    result = []\n    i = 0\n    while i < len(lst):\n        for p in perms_while(lst[:i]+lst[i+1:]):\n            result.append([lst[i]]+p)\n        i += 1\n    return result", "complexity": "O(n!)"},
    {"code": "def all_permutations_recursive(a, path=[]):\n    if not a:\n        print(path)\n    else:\n        for i in range(len(a)):\n            all_permutations_recursive(a[:i]+a[i+1:], path+[a[i]])", "complexity": "O(n!)"},
    {"code": "def permute_flags(a, used=None, path=[]):\n    if used is None:\n        used = [False]*len(a)\n    if len(path) == len(a):\n        print(path)\n        return\n    for i in range(len(a)):\n        if not used[i]:\n            used[i] = True\n            permute_flags(a, used, path+[a[i]])\n            used[i] = False", "complexity": "O(n!)"},
    {"code": "def string_permutations(s, path=''):\n    if not s:\n        print(path)\n    else:\n        for i in range(len(s)):\n            string_permutations(s[:i]+s[i+1:], path+s[i])", "complexity": "O(n!)"},
    {"code": "def double_for_with_cond(a, b):\n    for x in a:\n        for y in b:\n            if x != y:\n                print(x, y)", "complexity": "O(n^2)"},
    {"code": "def nested_while_for(arr):\n    i = 0\n    while i < len(arr):\n        for j in range(len(arr)):\n            arr[i] += arr[j]\n        i += 1", "complexity": "O(n^2)"},
    {"code": "def for_inside_func(a):\n    def inner(lst):\n        for x in lst:\n            print(x)\n    for y in a:\n        inner(a)", "complexity": "O(n^2)"},
    {"code": "def sum_matrix_columns(mat):\n    for col in range(len(mat[0])):\n        for row in range(len(mat)):\n            print(mat[row][col])", "complexity": "O(n^2)"},
    {"code": "def all_pairs_with_break(lst):\n    for i in lst:\n        for j in lst:\n            if i == j:\n                break\n            print(i, j)", "complexity": "O(n^2)"},

    {"code": "def three_while_mix(a):\n    i = 0\n    while i < len(a):\n        j = 0\n        while j < len(a):\n            for k in range(len(a)):\n                print(a[i], a[j], a[k])\n            j += 1\n        i += 1", "complexity": "O(n^3)"},
    {"code": "def deep_aux(a):\n    def aux(lst):\n        for j in lst:\n            for k in lst:\n                print(j, k)\n    for i in a:\n        aux(a)", "complexity": "O(n^3)"},
    {"code": "def conditional_triple(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                if i + j + k > 0:\n                    continue\n                print(i,j,k)", "complexity": "O(n^3)"},
    {"code": "def mixed_nested_for(a):\n    for i in a:\n        for j in a:\n            aux = lambda x: [y for y in a if y != x]\n            for z in aux(i):\n                print(i, j, z)", "complexity": "O(n^3)"},
    {"code": "def triple_for_non_consecutive(a):\n    for i in a:\n        for j in a:\n            print(i, j)\n        for k in a:\n            for l in a:\n                for m in a:\n                    print(k, l, m)", "complexity": "O(n^3)"},
    
    {"code": "def binary_strings(n):\n    if n == 0:\n        return ['']\n    res = []\n    for prefix in binary_strings(n-1):\n        res.append('0'+prefix)\n        res.append('1'+prefix)\n    return res", "complexity": "O(2^n)"},
    {"code": "def include_or_not(arr):\n    if not arr:\n        return [[]]\n    rest = include_or_not(arr[1:])\n    return rest + [[arr[0]]+x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def all_subsets_conditional(arr):\n    if not arr:\n        return [[]]\n    res = []\n    for subset in all_subsets_conditional(arr[1:]):\n        res.append(subset)\n        if arr[0] % 2 == 0:\n            res.append([arr[0]] + subset)\n    return res", "complexity": "O(2^n)"},
    {"code": "def subset_count(arr):\n    if not arr:\n        return 1\n    return subset_count(arr[1:]) + subset_count(arr[1:])", "complexity": "O(2^n)"},
    {"code": "def recursive_bifurcation(n, flag):\n    if n == 0:\n        return 1\n    if flag:\n        return recursive_bifurcation(n-1, False) + recursive_bifurcation(n-1, True)\n    else:\n        return recursive_bifurcation(n-1, True)", "complexity": "O(2^n)"},
    
    {"code": "def permute(lst):\n    if not lst:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for p in permute(lst[:i]+lst[i+1:]):\n            res.append([lst[i]]+p)\n    return res", "complexity": "O(n!)"},
    {"code": "def rec_with_for(a, path=[]):\n    if not a:\n        print(path)\n    else:\n        for i in range(len(a)):\n            rec_with_for(a[:i]+a[i+1:], path+[a[i]])", "complexity": "O(n!)"},
    {"code": "def permute_with_aux(lst):\n    def aux(remaining, path):\n        if not remaining:\n            print(path)\n            return\n        for i in range(len(remaining)):\n            aux(remaining[:i]+remaining[i+1:], path+[remaining[i]])\n    aux(lst, [])", "complexity": "O(n!)"},
    {"code": "def all_arrangements(arr):\n    if len(arr) == 0:\n        return [[]]\n    result = []\n    for i, x in enumerate(arr):\n        for a in all_arrangements(arr[:i]+arr[i+1:]):\n            result.append([x] + a)\n    return result", "complexity": "O(n!)"},
    {"code": "def string_permutations(s):\n    if len(s) == 1:\n        return [s]\n    res = []\n    for i in range(len(s)):\n        for p in string_permutations(s[:i]+s[i+1:]):\n            res.append(s[i] + p)\n    return res", "complexity": "O(n!)"},
    
    {"code": "def return_constant():\n    return 42", "complexity": "O(1)"},
    {"code": "def get_middle(a):\n    return a[len(a)//2]", "complexity": "O(1)"},
    {"code": "def sum_linear(a):\n    total = 0\n    for x in a:\n        total += x\n    return total", "complexity": "O(n)"},
    {"code": "def linear_find(a, val):\n    for x in a:\n        if x == val:\n            return True\n    return False", "complexity": "O(n)"},
    {"code": "def binary_search_variant(arr, target):\n    l, r = 0, len(arr)-1\n    while l < r:\n        m = (l + r) // 2\n        if arr[m] < target:\n            l = m + 1\n        else:\n            r = m\n    return l", "complexity": "O(log n)"},
    {"code": "def mergesort(lst):\n    if len(lst) <= 1:\n        return lst\n    mid = len(lst)//2\n    left = mergesort(lst[:mid])\n    right = mergesort(lst[mid:])\n    return merge(left, right)\ndef merge(a, b):\n    res = []\n    while a and b:\n        if a[0] < b[0]: res.append(a.pop(0))\n        else: res.append(b.pop(0))\n    return res+a+b", "complexity": "O(n log n)"},
    
    {"code": "def double_for_with_cond(a, b):\n    for x in a:\n        for y in b:\n            if x != y:\n                print(x, y)", "complexity": "O(n^2)"},
    {"code": "def nested_while_for(arr):\n    i = 0\n    while i < len(arr):\n        for j in range(len(arr)):\n            arr[i] += arr[j]\n        i += 1", "complexity": "O(n^2)"},
    {"code": "def for_inside_func(a):\n    def inner(lst):\n        for x in lst:\n            print(x)\n    for y in a:\n        inner(a)", "complexity": "O(n^2)"},
    {"code": "def sum_matrix_columns(mat):\n    for col in range(len(mat[0])):\n        for row in range(len(mat)):\n            print(mat[row][col])", "complexity": "O(n^2)"},
    {"code": "def all_pairs_with_break(lst):\n    for i in lst:\n        for j in lst:\n            if i == j:\n                break\n            print(i, j)", "complexity": "O(n^2)"},
    
    {"code": "def three_while_mix(a):\n    i = 0\n    while i < len(a):\n        j = 0\n        while j < len(a):\n            for k in range(len(a)):\n                print(a[i], a[j], a[k])\n            j += 1\n        i += 1", "complexity": "O(n^3)"},
    {"code": "def deep_aux(a):\n    def aux(lst):\n        for j in lst:\n            for k in lst:\n                print(j, k)\n    for i in a:\n        aux(a)", "complexity": "O(n^3)"},
    {"code": "def conditional_triple(a):\n    for i in a:\n        for j in a:\n            for k in a:\n                if i + j + k > 0:\n                    continue\n                print(i,j,k)", "complexity": "O(n^3)"},
    {"code": "def mixed_nested_for(a):\n    for i in a:\n        for j in a:\n            aux = lambda x: [y for y in a if y != x]\n            for z in aux(i):\n                print(i, j, z)", "complexity": "O(n^3)"},
    {"code": "def triple_for_non_consecutive(a):\n    for i in a:\n        for j in a:\n            print(i, j)\n        for k in a:\n            for l in a:\n                for m in a:\n                    print(k, l, m)", "complexity": "O(n^3)"},
   
    {"code": "def binary_strings(n):\n    if n == 0:\n        return ['']\n    res = []\n    for prefix in binary_strings(n-1):\n        res.append('0'+prefix)\n        res.append('1'+prefix)\n    return res", "complexity": "O(2^n)"},
    {"code": "def include_or_not(arr):\n    if not arr:\n        return [[]]\n    rest = include_or_not(arr[1:])\n    return rest + [[arr[0]]+x for x in rest]", "complexity": "O(2^n)"},
    {"code": "def all_subsets_conditional(arr):\n    if not arr:\n        return [[]]\n    res = []\n    for subset in all_subsets_conditional(arr[1:]):\n        res.append(subset)\n        if arr[0] % 2 == 0:\n            res.append([arr[0]] + subset)\n    return res", "complexity": "O(2^n)"},
    {"code": "def subset_count(arr):\n    if not arr:\n        return 1\n    return subset_count(arr[1:]) + subset_count(arr[1:])", "complexity": "O(2^n)"},
    {"code": "def recursive_bifurcation(n, flag):\n    if n == 0:\n        return 1\n    if flag:\n        return recursive_bifurcation(n-1, False) + recursive_bifurcation(n-1, True)\n    else:\n        return recursive_bifurcation(n-1, True)", "complexity": "O(2^n)"},
    
    {"code": "def permute(lst):\n    if not lst:\n        return [[]]\n    res = []\n    for i in range(len(lst)):\n        for p in permute(lst[:i]+lst[i+1:]):\n            res.append([lst[i]]+p)\n    return res", "complexity": "O(n!)"},
    {"code": "def rec_with_for(a, path=[]):\n    if not a:\n        print(path)\n    else:\n        for i in range(len(a)):\n            rec_with_for(a[:i]+a[i+1:], path+[a[i]])", "complexity": "O(n!)"},
    {"code": "def permute_with_aux(lst):\n    def aux(remaining, path):\n        if not remaining:\n            print(path)\n            return\n        for i in range(len(remaining)):\n            aux(remaining[:i]+remaining[i+1:], path+[remaining[i]])\n    aux(lst, [])", "complexity": "O(n!)"},
    {"code": "def all_arrangements(arr):\n    if len(arr) == 0:\n        return [[]]\n    result = []\n    for i, x in enumerate(arr):\n        for a in all_arrangements(arr[:i]+arr[i+1:]):\n            result.append([x] + a)\n    return result", "complexity": "O(n!)"},
    {"code": "def string_permutations(s):\n    if len(s) == 1:\n        return [s]\n    res = []\n    for i in range(len(s)):\n        for p in string_permutations(s[:i]+s[i+1:]):\n            res.append(s[i] + p)\n    return res", "complexity": "O(n!)"},
    {"code": "def return_constant():\n    return 42", "complexity": "O(1)"},
    {"code": "def get_middle(a):\n    return a[len(a)//2]", "complexity": "O(1)"},
    {"code": "def sum_linear(a):\n    total = 0\n    for x in a:\n        total += x\n    return total", "complexity": "O(n)"},
    {"code": "def linear_find(a, val):\n    for x in a:\n        if x == val:\n            return True\n    return False", "complexity": "O(n)"},
    {"code": "def binary_search_variant(arr, target):\n    l, r = 0, len(arr)-1\n    while l < r:\n        m = (l + r) // 2\n        if arr[m] < target:\n            l = m + 1\n        else:\n            r = m\n    return l", "complexity": "O(log n)"},
  
    {"code": "def triple_func(a):\n    def f(x):\n        for j in a:\n            for k in a:\n                print(x, j, k)\n    for i in a:\n        f(i)", "complexity": "O(n^3)"},
    {"code": "def separated_loops(a):\n    for x in a:\n        for y in a:\n            print(x, y)\n    for z in a:\n        for w in a:\n            for t in a:\n                print(z, w, t)", "complexity": "O(n^3)"},
    
    {"code": "def permute_alt(lst, path=[]):\n    if not lst:\n        print(path)\n        return\n    for i, x in enumerate(lst):\n        rest = lst[:i]+lst[i+1:]\n        permute_alt(rest, path+[x])", "complexity": "O(n!)"},
    {"code": "def permute_with_while(a):\n    if not a:\n        return [[]]\n    res = []\n    i = 0\n    while i < len(a):\n        for p in permute_with_while(a[:i]+a[i+1:]):\n            res.append([a[i]]+p)\n        i += 1\n    return res", "complexity": "O(n!)"},
    
    {"code": "def can_sum(arr, target):\n    if target == 0:\n        return True\n    if not arr:\n        return False\n    return can_sum(arr[1:], target) or can_sum(arr[1:], target-arr[0])", "complexity": "O(2^n)"},
  
    {"code": "def mergesort(lst):\n    if len(lst) <= 1:\n        return lst\n    mid = len(lst)//2\n    left = mergesort(lst[:mid])\n    right = mergesort(lst[mid:])\n    return merge(left, right)\ndef merge(a, b):\n    res = []\n    while a and b:\n        if a[0] < b[0]: res.append(a.pop(0))\n        else: res.append(b.pop(0))\n    return res+a+b", "complexity": "O(n log n)"}
  ]

}