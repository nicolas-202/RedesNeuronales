[
    {"complexity": "O(1)", "name": "get_first", "description": "Returns first element of a list", "code": "def get_first(lst):\n    return lst[0]"},
    {"complexity": "O(1)", "name": "is_even", "description": "Checks if a number is even", "code": "def is_even(n):\n    return n % 2 == 0"},
    {"complexity": "O(1)", "name": "square_num", "description": "Squares a number", "code": "def square_num(n):\n    return n * n"},
    {"complexity": "O(1)", "name": "dict_lookup", "description": "Looks up a key in dictionary", "code": "def dict_lookup(d, key):\n    return d[key]"},
    {"complexity": "O(1)", "name": "add_ten", "description": "Adds ten to a number", "code": "def add_ten(n):\n    return n + 10"},
    {"complexity": "O(1)", "name": "is_empty", "description": "Checks if list is empty", "code": "def is_empty(lst):\n    return len(lst) == 0"},
    {"complexity": "O(1)", "name": "get_last", "description": "Returns last element of a list", "code": "def get_last(lst):\n    return lst[-1]"},
    {"complexity": "O(1)", "name": "is_uppercase", "description": "Checks if string is uppercase", "code": "def is_uppercase(s):\n    return s.isupper()"},
    {"complexity": "O(1)", "name": "cube_num", "description": "Cubes a number", "code": "def cube_num(n):\n    return n ** 3"},
    {"complexity": "O(1)", "name": "is_digit", "description": "Checks if character is digit", "code": "def is_digit(c):\n    return c.isdigit()"},
    {"complexity": "O(1)", "name": "negate", "description": "Negates a number", "code": "def negate(n):\n    return -n"},
    {"complexity": "O(1)", "name": "get_length", "description": "Returns length of a list", "code": "def get_length(lst):\n    return len(lst)"},
    {"complexity": "O(1)", "name": "max_two", "description": "Returns maximum of two numbers", "code": "def max_two(a, b):\n    return a if a > b else b"},
    {"complexity": "O(1)", "name": "is_odd", "description": "Checks if a number is odd", "code": "def is_odd(n):\n    return n % 2 != 0"},
    {"complexity": "O(1)", "name": "get_char", "description": "Gets character at index", "code": "def get_char(s, idx):\n    return s[idx]"},
    {"complexity": "O(1)", "name": "is_zero", "description": "Checks if a number is zero", "code": "def is_zero(n):\n    return n == 0"},
    {"complexity": "O(1)", "name": "double", "description": "Doubles a number", "code": "def double(n):\n    return n * 2"},
    {"complexity": "O(1)", "name": "is_none", "description": "Checks if value is None", "code": "def is_none(x):\n    return x is None"},
    {"complexity": "O(1)", "name": "get_set_size", "description": "Returns size of a set", "code": "def get_set_size(s):\n    return len(s)"},
    {"complexity": "O(1)", "name": "is_positive", "description": "Checks if a number is positive", "code": "def is_positive(n):\n    return n > 0"},

    {"complexity": "O(log n)", "name": "binary_search", "description": "Performs binary search", "code": "def binary_search(arr, target):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1"},
    {"complexity": "O(log n)", "name": "power_two", "description": "Checks if number is power of two", "code": "def power_two(n):\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n    return True"},
    {"complexity": "O(log n)", "name": "sqrt_int", "description": "Finds integer square root", "code": "def sqrt_int(n):\n    left, right = 0, n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid <= n < (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid > n:\n            right = mid - 1\n        else:\n            left = mid + 1"},
    {"complexity": "O(log n)", "name": "find_peak", "description": "Finds peak element in array", "code": "def find_peak(arr):\n    left, right = 0, len(arr)-1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < arr[mid+1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left"},
    {"complexity": "O(log n)", "name": "power_three", "description": "Checks if number is power of three", "code": "def power_three(n):\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 3 != 0:\n            return False\n        n //= 3\n    return True"},
    {"complexity": "O(log n)", "name": "log_count", "description": "Counts logarithmic steps", "code": "def log_count(n):\n    count = 0\n    while n > 1:\n        n //= 2\n        count += 1\n    return count"},
    {"complexity": "O(log n)", "name": "find_floor", "description": "Finds floor of target", "code": "def find_floor(arr, target):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return arr[mid]\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return arr[right] if right >= 0 else None"},
    {"complexity": "O(log n)", "name": "find_ceiling", "description": "Finds ceiling of target", "code": "def find_ceiling(arr, target):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return arr[mid]\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return arr[left] if left < len(arr) else None"},
    {"complexity": "O(log n)", "name": "count_digits", "description": "Counts digits in a number", "code": "def count_digits(n):\n    if n == 0:\n        return 1\n    count = 0\n    while n > 0:\n        n //= 10\n        count += 1\n    return count"},
    {"complexity": "O(log n)", "name": "power_five", "description": "Checks if number is power of five", "code": "def power_five(n):\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 5 != 0:\n            return False\n        n //= 5\n    return True"},
    {"complexity": "O(log n)", "name": "find_pivot", "description": "Finds pivot in rotated array", "code": "def find_pivot(arr):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if mid < len(arr)-1 and arr[mid] > arr[mid+1]:\n            return mid\n        if arr[mid] > arr[0]:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1"},
    {"complexity": "O(log n)", "name": "log_base_three", "description": "Calculates log base 3", "code": "def log_base_three(n):\n    if n < 1:\n        return -1\n    count = 0\n    while n > 1:\n        n //= 3\n        count += 1\n    return count"},
    {"complexity": "O(log n)", "name": "cube_root", "description": "Finds integer cube root", "code": "def cube_root(n):\n    left, right = 0, n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid ** 3 <= n < (mid + 1) ** 3:\n            return mid\n        elif mid ** 3 > n:\n            right = mid - 1\n        else:\n            left = mid + 1"},
    {"complexity": "O(log n)", "name": "find_min_rotated", "description": "Finds minimum in rotated array", "code": "def find_min_rotated(arr):\n    left, right = 0, len(arr)-1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] > arr[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return arr[left]"},
    {"complexity": "O(log n)", "name": "power_seven", "description": "Checks if number is power of seven", "code": "def power_seven(n):\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 7 != 0:\n            return False\n        n //= 7\n    return True"},
    {"complexity": "O(log n)", "name": "first_one", "description": "Finds first 1 in binary array", "code": "def first_one(arr):\n    left, right = 0, len(arr)-1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == 1:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result"},
    {"complexity": "O(log n)", "name": "log_base_five", "description": "Calculates log base 5", "code": "def log_base_five(n):\n    if n < 1:\n        return -1\n    count = 0\n    while n > 1:\n        n //= 5\n        count += 1\n    return count"},
    {"complexity": "O(log n)", "name": "search_rotated", "description": "Searches in rotated sorted array", "code": "def search_rotated(arr, target):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        if arr[left] <= arr[mid]:\n            if arr[left] <= target < arr[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if arr[mid] < target <= arr[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1"},
    {"complexity": "O(log n)", "name": "power_ten", "description": "Checks if number is power of ten", "code": "def power_ten(n):\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 10 != 0:\n            return False\n        n //= 10\n    return True"},
    {"complexity": "O(log n)", "name": "fourth_root", "description": "Finds integer fourth root", "code": "def fourth_root(n):\n    left, right = 0, n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid ** 4 <= n < (mid + 1) ** 4:\n            return mid\n        elif mid ** 4 > n:\n            right = mid - 1\n        else:\n            left = mid + 1"},


    {"complexity": "O(n)", "name": "sum_list", "description": "Sums all elements in a list", "code": "def sum_list(lst):\n    total = 0\n    for x in lst:\n        total += x\n    return total"},
    {"complexity": "O(n)", "name": "find_max", "description": "Finds maximum element", "code": "def find_max(lst):\n    max_val = lst[0]\n    for x in lst:\n        if x > max_val:\n            max_val = x\n    return max_val"},
    {"complexity": "O(n)", "name": "linear_search", "description": "Performs linear search", "code": "def linear_search(lst, target):\n    for i, x in enumerate(lst):\n        if x == target:\n            return i\n    return -1"},
    {"complexity": "O(n)", "name": "count_evens", "description": "Counts even numbers", "code": "def count_evens(lst):\n    count = 0\n    for x in lst:\n        if x % 2 == 0:\n            count += 1\n    return count"},
    {"complexity": "O(n)", "name": "reverse_list", "description": "Reverses a list", "code": "def reverse_list(lst):\n    result = []\n    for x in lst:\n        result.insert(0, x)\n    return result"},
    {"complexity": "O(n)", "name": "filter_positive", "description": "Filters positive numbers", "code": "def filter_positive(lst):\n    return [x for x in lst if x > 0]"},
    {"complexity": "O(n)", "name": "count_vowels", "description": "Counts vowels in string", "code": "def count_vowels(s):\n    return sum(1 for c in s.lower() if c in 'aeiou')"},
    {"complexity": "O(n)", "name": "double_list", "description": "Doubles each element", "code": "def double_list(lst):\n    return [x * 2 for x in lst]"},
    {"complexity": "O(n)", "name": "find_min", "description": "Finds minimum element", "code": "def find_min(lst):\n    min_val = lst[0]\n    for x in lst:\n        if x < min_val:\n            min_val = x\n    return min_val"},
    {"complexity": "O(n)", "name": "is_sorted", "description": "Checks if list is sorted", "code": "def is_sorted(lst):\n    for i in range(len(lst)-1):\n        if lst[i] > lst[i+1]:\n            return False\n    return True"},
    {"complexity": "O(n)", "name": "rotate_right", "description": "Rotates list right", "code": "def rotate_right(lst):\n    if not lst:\n        return lst\n    return [lst[-1]] + lst[:-1]"},
    {"complexity": "O(n)", "name": "sum_squares", "description": "Sums squares of elements", "code": "def sum_squares(lst):\n    return sum(x * x for x in lst)"},
    {"complexity": "O(n)", "name": "count_char", "description": "Counts character in string", "code": "def count_char(s, c):\n    return sum(1 for x in s if x == c)"},
    {"complexity": "O(n)", "name": "remove_duplicates", "description": "Removes duplicates", "code": "def remove_duplicates(lst):\n    seen = set()\n    result = []\n    for x in lst:\n        if x not in seen:\n            seen.add(x)\n            result.append(x)\n    return result"},
    {"complexity": "O(n)", "name": "shift_left", "description": "Shifts list left", "code": "def shift_left(lst):\n    return lst[1:] + [lst[0]]"},
    {"complexity": "O(n)", "name": "sum_odds", "description": "Sums odd numbers", "code": "def sum_odds(lst):\n    return sum(x for x in lst if x % 2 != 0)"},
    {"complexity": "O(n)", "name": "replace_value", "description": "Replaces value in list", "code": "def replace_value(lst, old, new):\n    return [new if x == old else x for x in lst]"},
    {"complexity": "O(n)", "name": "count_greater", "description": "Counts elements greater than x", "code": "def count_greater(lst, x):\n    return sum(1 for y in lst if y > x)"},
    {"complexity": "O(n)", "name": "sum_digits", "description": "Sums digits in string", "code": "def sum_digits(s):\n    return sum(int(c) for c in s if c.isdigit())"},
    {"complexity": "O(n)", "name": "filter_non_empty", "description": "Filters non-empty strings", "code": "def filter_non_empty(lst):\n    return [s for s in lst if s]"},

 
    {"complexity": "O(n log n)", "name": "sort_list", "description": "Sorts a list", "code": "def sort_list(lst):\n    return sorted(lst)"},
    {"complexity": "O(n log n)", "name": "merge_sort", "description": "Performs merge sort", "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"},
    {"complexity": "O(n log n)", "name": "sort_by_length", "description": "Sorts strings by length", "code": "def sort_by_length(lst):\n    return sorted(lst, key=len)"},
    {"complexity": "O(n log n)", "name": "kth_largest", "description": "Finds kth largest element", "code": "def kth_largest(lst, k):\n    return sorted(lst, reverse=True)[k-1]"},
    {"complexity": "O(n log n)", "name": "sort_by_sum", "description": "Sorts lists by sum", "code": "def sort_by_sum(lst):\n    return sorted(lst, key=sum)"},
    {"complexity": "O(n log n)", "name": "merge_k_lists", "description": "Merges k sorted lists", "code": "def merge_k_lists(lists):\n    from heapq import heappush, heappop\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heappush(heap, (lst[0], i, 0))\n    result = []\n    while heap:\n        val, list_idx, idx = heappop(heap)\n        result.append(val)\n        if idx + 1 < len(lists[list_idx]):\n            heappush(heap, (lists[list_idx][idx+1], list_idx, idx+1))\n    return result"},
    {"complexity": "O(n log n)", "name": "sort_by_vowels", "description": "Sorts by vowel count", "code": "def sort_by_vowels(lst):\n    def count_vowels(s):\n        return sum(1 for c in s.lower() if c in 'aeiou')\n    return sorted(lst, key=count_vowels)"},
    {"complexity": "O(n log n)", "name": "min_pair_diff", "description": "Finds minimum pair difference", "code": "def min_pair_diff(lst):\n    lst.sort()\n    return min(lst[i+1] - lst[i] for i in range(len(lst)-1))"},
    {"complexity": "O(n log n)", "name": "sort_by_reverse", "description": "Sorts strings by reverse", "code": "def sort_by_reverse(lst):\n    return sorted(lst, key=lambda x: x[::-1])"},
    {"complexity": "O(n log n)", "name": "k_largest_pairs", "description": "Finds k largest pairs", "code": "def k_largest_pairs(nums1, nums2, k):\n    import heapq\n    heap = [(-nums1[0]-nums2[0], 0, 0)]\n    result = []\n    seen = set([(0, 0)])\n    while heap and len(result) < k:\n        total, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if i + 1 < len(nums1) and (i + 1, j) not in seen:\n            heapq.heappush(heap, (-nums1[i+1]-nums2[j], i+1, j))\n            seen.add((i+1, j))\n        if j + 1 < len(nums2) and (i, j+1) not in seen:\n            heapq.heappush(heap, (-nums1[i]-nums2[j+1], i, j+1))\n            seen.add((i, j+1))\n    return result"},
    {"complexity": "O(n log n)", "name": "sort_by_modulo", "description": "Sorts by modulo m", "code": "def sort_by_modulo(lst, m):\n    return sorted(lst, key=lambda x: x % m)"},
    {"complexity": "O(n log n)", "name": "max_product_three", "description": "Finds max product of three numbers", "code": "def max_product_three(nums):\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},
    {"complexity": "O(n log n)", "name": "sort_by_digit_sum", "description": "Sorts by sum of digits", "code": "def sort_by_digit_sum(lst):\n    def digit_sum(n):\n        return sum(int(d) for d in str(abs(n)))\n    return sorted(lst, key=digit_sum)"},
    {"complexity": "O(n log n)", "name": "k_smallest_pairs", "description": "Finds k smallest pairs", "code": "def k_smallest_pairs(nums1, nums2, k):\n    import heapq\n    heap = [(nums1[0]+nums2[0], 0, 0)]\n    result = []\n    seen = set([(0, 0)])\n    while heap and len(result) < k:\n        total, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if i + 1 < len(nums1) and (i+1, j) not in seen:\n            heapq.heappush(heap, (nums1[i+1]+nums2[j], i+1, j))\n            seen.add((i+1, j))\n        if j + 1 < len(nums2) and (i, j+1) not in seen:\n            heapq.heappush(heap, (nums1[i]+nums2[j+1], i, j+1))\n            seen.add((i, j+1))\n    return result"},
    {"complexity": "O(n log n)", "name": "sort_by_frequency", "description": "Sorts by frequency of elements", "code": "def sort_by_frequency(lst):\n    from collections import Counter\n    return sorted(lst, key=lambda x: (-Counter(lst)[x], x))"},
    {"complexity": "O(n log n)", "name": "sort_by_last_char", "description": "Sorts by last character", "code": "def sort_by_last_char(lst):\n    return sorted(lst, key=lambda x: x[-1] if x else '')"},
    {"complexity": "O(n log n)", "name": "kth_smallest", "description": "Finds kth smallest element", "code": "def kth_smallest(lst, k):\n    return sorted(lst)[k-1]"},
    {"complexity": "O(n log n)", "name": "sort_by_product", "description": "Sorts lists by product", "code": "def sort_by_product(lst):\n    def product(nums):\n        p = 1\n        for x in nums:\n            p *= x\n        return p\n    return sorted(lst, key=product)"},
    {"complexity": "O(n log n)", "name": "sort_by_diff", "description": "Sorts pairs by difference", "code": "def sort_by_diff(pairs):\n    return sorted(pairs, key=lambda x: x[1] - x[0])"},
    {"complexity": "O(n log n)", "name": "sort_by_max", "description": "Sorts lists by maximum element", "code": "def sort_by_max(lst):\n    return sorted(lst, key=max)"},


    {"complexity": "O(n^2)", "name": "bubble_sort", "description": "Performs bubble sort", "code": "def bubble_sort(lst):\n    n = len(lst)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if lst[j] > lst[j+1]:\n                lst[j], lst[j+1] = lst[j+1], lst[j]\n    return lst"},
    {"complexity": "O(n^2)", "name": "selection_sort", "description": "Performs selection sort", "code": "def selection_sort(lst):\n    for i in range(len(lst)):\n        min_idx = i\n        for j in range(i+1, len(lst)):\n            if lst[j] < lst[min_idx]:\n                min_idx = j\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n    return lst"},
    {"complexity": "O(n^2)", "name": "count_pairs", "description": "Counts pairs with given sum", "code": "def count_pairs(nums, target):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                count += 1\n    return count"},
    {"complexity": "O(n^2)", "name": "longest_common_substring", "description": "Finds longest common substring", "code": "def longest_common_substring(s1, s2):\n    max_len = 0\n    result = ''\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            k = 0\n            while i+k < len(s1) and j+k < len(s2) and s1[i+k] == s2[j+k]:\n                k += 1\n            if k > max_len:\n                max_len = k\n                result = s1[i:i+k]\n    return result"},
    {"complexity": "O(n^2)", "name": "matrix_diagonal_sum", "description": "Sums matrix diagonals", "code": "def matrix_diagonal_sum(matrix):\n    n = len(matrix)\n    total = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n-1:\n                total += matrix[i][j]\n    return total"},
    {"complexity": "O(n^2)", "name": "count_inversions", "description": "Counts inversions in array", "code": "def count_inversions(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count"},
    {"complexity": "O(n^2)", "name": "max_subarray_sum", "description": "Finds max subarray sum", "code": "def max_subarray_sum(nums):\n    max_sum = float('-inf')\n    for i in range(len(nums)):\n        curr_sum = 0\n        for j in range(i, len(nums)):\n            curr_sum += nums[j]\n            max_sum = max(max_sum, curr_sum)\n    return max_sum"},
    {"complexity": "O(n^2)", "name": "rotate_array", "description": "Rotates array k times", "code": "def rotate_array(nums, k):\n    k = k % len(nums)\n    for _ in range(k):\n        last = nums[-1]\n        for i in range(len(nums)-1, 0, -1):\n            nums[i] = nums[i-1]\n        nums[0] = last\n    return nums"},
    {"complexity": "O(n^2)", "name": "count_triplets", "description": "Counts triplets with sum zero", "code": "def count_triplets(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    count += 1\n    return count"},
    {"complexity": "O(n^2)", "name": "is_valid_sudoku", "description": "Checks if Sudoku board is valid", "code": "def is_valid_sudoku(board):\n    for i in range(9):\n        seen = set()\n        for j in range(9):\n            if board[i][j] != '.' and board[i][j] in seen:\n                return False\n            seen.add(board[i][j])\n    return True"},
    {"complexity": "O(n^2)", "name": "count_smaller", "description": "Counts smaller elements", "code": "def count_smaller(lst):\n    result = []\n    for i in range(len(lst)):\n        count = 0\n        for j in range(len(lst)):\n            if lst[j] < lst[i]:\n                count += 1\n        result.append(count)\n    return result"},
    {"complexity": "O(n^2)", "name": "matrix_spiral", "description": "Returns matrix in spiral order", "code": "def matrix_spiral(matrix):\n    if not matrix:\n        return []\n    result = []\n    top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\n    while top <= bottom and left <= right:\n        for j in range(left, right+1):\n            result.append(matrix[top][j])\n        top += 1\n        for i in range(top, bottom+1):\n            result.append(matrix[i][right])\n        right -= 1\n        if top <= bottom:\n            for j in range(right, left-1, -1):\n                result.append(matrix[bottom][j])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top-1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    return result"},
    {"complexity": "O(n^2)", "name": "count_diff_k", "description": "Counts pairs with difference k", "code": "def count_diff_k(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if abs(nums[i] - nums[j]) == k:\n                count += 1\n    return count"},
    {"complexity": "O(n^2)", "name": "max_sum_triangle", "description": "Finds max sum in triangle", "code": "def max_sum_triangle(triangle):\n    dp = triangle[-1][:]\n    for i in range(len(triangle)-2, -1, -1):\n        new_dp = []\n        for j in range(len(triangle[i])):\n            new_dp.append(triangle[i][j] + max(dp[j], dp[j+1]))\n        dp = new_dp\n    return dp[0]"},
    {"complexity": "O(n^2)", "name": "count_equal_pairs", "description": "Counts equal pairs", "code": "def count_equal_pairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] == nums[j]:\n                count += 1\n    return count"},
    {"complexity": "O(n^2)", "name": "find_common", "description": "Finds common elements in two lists", "code": "def find_common(lst1, lst2):\n    result = []\n    for x in lst1:\n        for y in lst2:\n            if x == y and x not in result:\n                result.append(x)\n    return result"},
    {"complexity": "O(n^2)", "name": "count_subarrays", "description": "Counts subarrays with sum k", "code": "def count_subarrays(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        curr_sum = 0\n        for j in range(i, len(nums)):\n            curr_sum += nums[j]\n            if curr_sum == k:\n                count += 1\n    return count"},
{"complexity": "O(n^2)", "name": "is_valid_column_sudoku", "description": "Checks if Sudoku columns are valid", "code": "def is_valid_column_sudoku(board):\n    for j in range(len(board[0])):\n        seen = set()\n        for i in range(len(board)):\n            num = board[i][j]\n            if num != '.' and num in seen:\n                return False\n            seen.add(num)\n    return True"},
    {"complexity": "O(n^2)", "name": "count_larger_pairs", "description": "Counts pairs where first is larger", "code": "def count_larger_pairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] > nums[j]:\n                count += 1\n    return count"},
    {"complexity": "O(n^2)", "name": "find_duplicate_pairs", "description": "Finds duplicate pairs", "code": "def find_duplicate_pairs(nums):\n    pairs = []\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] == nums[j]:\n                pairs.append((nums[i], nums[j]))\n    return pairs"},


    {"complexity": "O(n^3)", "name": "triple_loop_sum", "description": "Sums all elements in three nested loops", "code": "def triple_loop_sum(n):\n    total = 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                total += i + j + k\n    return total"},
    {"complexity": "O(n^3)", "name": "matrix_multiply", "description": "Performs matrix multiplication", "code": "def matrix_multiply(A, B):\n    n = len(A)\n    result = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                result[i][j] += A[i][j] * B[k][j]\n    return result"},
    {"complexity": "O(n^3)", "name": "count_triplets_sum", "description": "Counts triplets with given sum", "code": "def count_triplets_sum(nums, target):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] + nums[k]:\n                    count += 1\n    return count"},
    {"complexity": "O(n^3)", "name": "all_subarrays_sum", "description": "Sums all possible subarrays", "code": "def all_subarrays_sum(nums):\n    total = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            for k in range(i, len(nums)+1):\n                total += sum(nums[i:j+1)\n    return total"},
    {"complexity": "O(n^3)", "name": "transitive_closure", "description": "Computes transitive closure of graph", "code": "def transitive_closure(graph):\n    n = len(graph)\n    reach = [[graph[i][j] for j in range(n)] for i in range(n)]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][k])\n    return reach"},
    {"complexity": "O(n^3)", "name": "count_triple_pairs", "description": "Counts valid triple pairs", "code": "def count_triple_pairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            for k in range(len(nums)):\n                if nums[i] + nums[j] > nums[k]:\n                    count += 1\n    return count"},
    {"complexity": "O(n^3)", "name": "max_product_triplet", "description": "Finds product of triplet", "code": "def max_product_triplet(nums):\n    max_prod = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                max_prod = max(max_prod, nums[i] * nums[j] * nums[k])\n    return max_prod"},
    {"complexity": "O(n^3)", "name": "count_subarrays_k", "description": "Counts subarrays with product k", "code": "def count_subarrays_k(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            prod = 1\n            for m in range(i, j+1):\n                prod *= nums[m]\n            if prod == k:\n                count += 1\n    return count"},
    {"complexity": "O(n^3)", "name": "floyd_warshall", "description": "Floyd-Warshall shortest paths", "code": "def floyd_warshall(graph):\n    n = len(graph)\n    dist = [[graph[i][j] for j in range(n)] for i in range(n)]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist"},
    {"complexity": "O(n^3)", "name": "count_triangles", "description": "Counts triangles in graph", "code": "def count_triangles(graph):\n    n = len(graph)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if graph[i][j] and graph[j][k] and graph[k][i]:\n                    count += 1\n    return count"},
    {"complexity": "O(n^3)", "name": "max_sum_submatrix", "description": "Finds max sum submatrix", "code": "def max_sum_submatrix(matrix):\n    n = len(matrix)\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(n):\n            for k in range(i, n):\n                for l in range(j, n):\n                    curr_sum = sum(matrix[r][c] for r in range(i, k+1) for c in range(j, l+1))\n                    max_sum = max(max_sum, curr_sum)\n    return max_sum"},
    {"complexity": "O(n^3)", "name": "count_equal_triplets", "description": "Counts equal triplets", "code": "def count_equal_triplets(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] == nums[j] == nums[k]:\n                    count += 1\n    return count"},
    {"complexity": "O(n^3)", "name": "all_pairs_product", "description": "Computes all pairs product", "code": "def all_pairs_product(nums):\n    result = []\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            for k in range(len(nums)):\n                result.append(nums[i] * nums[j] * nums[k])\n    return result"},
    {"complexity": "O(n^3)", "name": "count_subsets_sum", "description": "Counts subsets with sum k", "code": "def count_subsets_sum(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            curr_sum = 0\n            for m in range(i, j+1):\n                curr_sum += nums[m]\n            if curr_sum == k:\n                count += 1\n    return count"},
    {"complexity": "O(n^3)", "name": "max_diff_triplet", "description": "Finds max difference triplet", "code": "def max_diff_triplet(nums):\n    max_diff = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                diff = abs(nums[k] - nums[i])\n                max_diff = max(max_diff, diff)\n    return max_diff"},
    {"complexity": "O(n^3)", "name": "count_valid_triplets", "description": "Counts valid triplets", "code": "def count_valid_triplets(nums, target):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] + nums[k] <= target:\n                    count += 1\n    return count"},
    {"complexity": "O(n^3)", "name": "all_subarrays_product", "description": "Computes all subarrays product", "code": "def all_subarrays_product(nums):\n    result = []\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            prod = 1\n            for k in range(i, j+1):\n                prod *= nums[k]\n            result.append(prod)\n    return result"},
    {"complexity": "O(n^3)", "name": "count_triplet_pairs", "description": "Counts triplet pairs with sum", "code": "def count_triplet_pairs(nums, target):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] == nums[k]:\n                    count += 1\n    return count"},
    {"complexity": "O(n^3)", "name": "max_sum_triplet", "description": "Finds max sum of triplet", "code": "def max_sum_triplet(nums):\n    max_sum = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                max_sum = max(max_sum, nums[i] + nums[j] + nums[k])\n    return max_sum"},
    {"complexity": "O(n^3)", "name": "count_diff_triplets", "description": "Counts triplets with diff k", "code": "def count_diff_triplets(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k or abs(nums[j] - nums[k]) == k:\n                    count += 1\n    return count"},

    {"complexity": "O(2^n)", "name": "generate_subsets", "description": "Generates all subsets", "code": "def generate_subsets(nums):\n    result = []\n    def backtrack(i, curr):\n        result.append(curr[:])\n        for j in range(i, len(nums)):\n            backtrack(j+1, curr + [nums[j]])\n    backtrack(0, [])\n    return result"},
    {"complexity": "O(2^n)", "name": "subset_sum", "description": "Finds subsets with sum target", "code": "def subset_sum(nums, target):\n    result = []\n    def backtrack(i, curr, curr_sum):\n        if curr_sum == target:\n            result.append(curr[:])\n        if i >= len(nums) or curr_sum > target:\n            return\n        backtrack(i+1, curr + [nums[i]]], curr_sum + nums[i])\n        backtrack(i+1, curr, curr_sum)\n    backtrack(0, [], 0)\n    return result"},
    {"complexity": "O(2^n)", "name": "generate_permutations", "description": "Generates all permutations", "code": "def generate_perms(nums):\n    result = []\n    def backtrack(curr, remaining):\n        if not remaining:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            backtrack(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    backtrack([], nums)\n    return result"},
    {"complexity": "O(2^n)", "name": "solve_n_queens", "description": "Solves N-Queens problem", "code": "def solve_n_queens(n):\n    result = []\n    def backtrack(row, cols, diag1, diag2):\n        if row == n:\n            result.append(['.' * c + 'Q' + '.' * (n-c-1) for c in cols])\n        for col in range(n):\n            if col not in cols and row+col not in diag1 and row-col not in diag2:\n                cols.add(col)\n                diag1.add(row+col)\n                diag2.add(row-col)\n                backtrack(row+1, cols, diag1, diag2)\n                cols.remove(col)\n                diag1.remove(row+col)\n                diag2.remove(row-col)\n    backtrack(0, set(), set(), set())\n    return result"},
    {"complexity": "O(2^n)", "name": "max_subset_sum", "description": "Finds max subset sum", "code": "def max_subset_sum(nums):\n    max_sum = float('-inf')\n    result = []\n    def backtrack(i, curr, curr_sum):\n        nonlocal max_sum, result\n        if i == len(nums):\n            if curr_sum > max_sum:\n                max_sum = curr_sum\n                result = curr[:]\n            return\n        backtrack(i+1, curr + [nums[i]], curr_sum + nums[i])\n        backtrack(i+1, curr, curr_sum)\n    backtrack(0, [], 0)\n    return result"},
    {"complexity": "O(2^n)", "name": "generate_combinations", "description": "Generates combinations", "code": "def generate_combinations(n, k):\n    result = []\n    def backtrack(start, curr):\n        if len(curr) == k:\n            result.append(curr[:])\n            return\n        for i in range(start, n+1):\n            backtrack(i+1, curr + [i])\n    backtrack(1, [])\n    return result"},
    {"complexity": "O(2^n)", "name": "partition_equal_sum", "description": "Partitions array into equal sums", "code": "def partition_equal_sum(nums):\n    target = sum(nums) / 2\n    result = []\n    def backtrack(i, curr, curr_sum):\n        if curr_sum == target:\n            result.append(curr[:])\n            return\n        if i >= len(nums) or curr_sum > target:\n            return\n        backtrack(i+1, curr + [nums[i]], curr_sum + nums[i])\n        backtrack(i+1, curr, curr_sum)\n    backtrack(0, [], 0)\n    return result"},
    {"complexity": "O(2^n)", "name": "generate_gray_code", "description": "Generates Gray code", "code": "def generate_gray_code(n):\n    if n == 0:\n        return ['']\n    prev = generate_gray_code(n-1)\n    return [s + '0' for s in prev] + [s + '1' for s in prev[::-1]]"},
    {"complexity": "O(2^n)", "name": "solve_sudoku", "description": "Solves Sudoku board", "code": "def solve_sudoku(board):\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n            if board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n                return False\n        return True\n    def backtrack():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    for num in '123456789':\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if backtrack():\n                                return True\n                            board[i][j] = '.'\n                    return False\n        return True\n    return backtrack()"},
    {"complexity": "O(2^n)", "name": "max_non_adjacent_sum", "description": "Finds max non-adjacent sum", "code": "def max_non_adjacent_sum(nums):\n    def backtrack(i, curr_sum, last):\n        if i >= len(nums):\n            return curr_sum\n        if last != i-1:\n            include = backtrack(i+2, curr_sum + nums[i], i)\n        else:\n            include = float('-inf')\n        exclude = backtrack(i+1, curr_sum, last)\n        return max(include, exclude)\n    return backtrack(0, 0, -2)"},
    {"complexity": "O(2^n)", "name": "generate_valid_ip", "description": "Generates valid IP addresses", "code": "def generate_valid_ip(s):\n    result = []\n    def is_valid_part(part):\n        return len(part) == 1 or (part[0] != '0' and int(part) <= 255)\n    def backtrack(i, curr, parts):\n        if parts == 4 and i == len(s):\n            result.append('.'.join(curr))\n            return\n        if parts >= 4 or i >= len(s):\n            return\n        for j in range(i, min(i+3, len(s))):\n            part = s[i:j+1]\n            if is_valid_part(part):\n                backtrack(j+1, curr + [part], parts + 1)\n    backtrack(0, [], 0)\n    return result"},
    {"complexity": "O(2^n)", "name": "subset_product", "description": "Finds subsets with product target", "code": "def subset_product(nums, target):\n    result = []\n    def backtrack(i, curr, prod):\n        if prod == target and curr:\n            result.append(curr[:])\n        if i == len(nums) or prod > target and target > 0:\n            return\n        backtrack(i+1, curr + [nums[i]], prod * nums[i])\n        backtrack(i+1, curr, prod)\n    backtrack(0, [], 1)\n    return result"},
    {"complexity": "O(2^n)", "name": "generate_letter_combinations", "description": "Generates letter combinations for phone number", "code": "def generate_letter_combinations(digits):\n    mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    result = []\n    def backtrack(i, curr):\n        if i == len(digits):\n            result.append(curr)\n            return\n        for c in mapping[digits[i]]:\n            backtrack(i+1, curr + c)\n    if digits:\n        backtrack(0, '')\n    return result"},
    {"complexity": "O(2^n)", "name": "max_subset_product", "description": "Finds max subset product", "code": "def max_subset_product(nums):\n    max_prod = float('-inf')\n    result = []\n    def backtrack(i, curr, prod):\n        nonlocal max_prod, result\n        if i == len(nums):\n            if prod > max_prod and curr:\n                max_prod = prod\n                result = curr[:]\n            return\n        backtrack(i+1, curr + [nums[i]], prod * nums[i])\n        backtrack(i+1, curr, prod)\n    backtrack(0, [], 1)\n    return result"},
    {"complexity": "O(2^n)", "name": "partition_array", "description": "Partitions array into two parts", "code": "def partition_array(nums):\n    target = sum(nums) / 2\n    min_diff = float('inf')\n    result = []\n    def backtrack(i, curr, curr_sum):\n        nonlocal min_diff, result\n        if i == len(nums):\n            other_sum = sum(nums) - curr_sum\n            diff = abs(curr_sum - other_sum)\n            if diff < min_diff:\n                min_diff = diff\n                result = curr[:]\n            return\n        backtrack(i+1, curr + [nums[i]], curr_sum + nums[i])\n        backtrack(i+1, curr, curr_sum)\n    backtrack(0, [], 0)\n    return result"},
    {"complexity": "O(2^n)", "name": "generate_binary_strings", "description": "Generates binary strings", "code": "def generate_binary_strings(n):\n    result = []\n    def backtrack(curr, remaining):\n        if remaining == 0:\n            result.append(curr)\n            return\n        backtrack(curr + '0', remaining-1)\n        backtrack(curr + '1', remaining-1)\n    backtrack('', n)\n    return result"},
    {"complexity": "O(2^n)", "name": "subset_min_diff", "description": "Finds subset with min sum", "code": "def subset_min_sum(nums):\n    min_sum = float('inf')\n    result = []\n    def backtrack(i, curr, curr_sum):\n        nonlocal min_sum, result\n        if i == len(nums):\n            if curr and curr_sum < min_sum:\n                min_sum = curr_sum\n                result = curr[:]\n            return\n        backtrack(i+1, curr + [nums[i]], curr_sum + nums[i])\n        backtrack(i+1, curr, curr_sum)\n    backtrack(0, [], 0)\n    return result"},
    {"complexity": "O(2^n)", "name": "generate_valid_sequences", "description": "Generates valid sequences", "code": "def generate_valid_sequences(n):\n    result = []\n    def backtrack(curr, open_count, remaining):\n        if remaining == 0:\n            if open_count == 0:\n                result.append(curr)\n            return\n        if open_count < remaining:\n            backtrack(curr + '(', open_count + 1, remaining - 1)\n        if open_count > 0:\n            backtrack(curr + ')', open_count - 1, remaining - 1)\n    backtrack('', 0, 2*n)\n    return result"},
    {"complexity": "O(2^n)", "name": "subset_max_count", "description": "Finds subset with max count", "code": "def subset_max_count(nums, k):\n    max_count = 0\n    result = []\n    def backtrack(i, curr, curr_sum):\n        nonlocal max_count, result\n        if i == len(nums):\n            if curr_sum == k and len(curr) > max_count:\n                max_count = len(curr)\n                result = curr[:]\n            return\n        backtrack(i+1, curr + [nums[i]], curr_sum + nums[i])\n        backtrack(i+1, curr, curr_sum)\n    backtrack(0, [], 0)\n    return result"},
    {"complexity": "O(2^n)", "name": "generate_subsets_k", "description": "Generates subsets of size k", "code": "def generate_subsets_k(nums, k):\n    result = []\n    def backtrack(i, curr):\n        if len(curr) == k:\n            result.append(curr[:])\n            return\n        if i >= len(nums):\n            return\n        backtrack(i+1, curr + [nums[i]])\n        backtrack(i+1, curr)\n    backtrack(0, [])\n    return result"},


    {"complexity": "O(n!)", "name": "all_permutations", "description": "Generates all permutations", "code": "def all_permutations(nums):\n    result = []\n    def permute(curr, remaining):\n        if not remaining:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], nums)\n    return result"},
    {"complexity": "O(n!)", "name": "tsp_brute_force", "description": "Solves TSP using brute force", "code": "def tsp_brute_force(graph):\n    n = len(graph)\n    vertices = [i for i in range(1, n)]\n    min_cost = float('inf')\n    def permute(curr, remaining):\n        nonlocal min_cost\n        if not remaining:\n            cost = graph[curr[-1]][0] + graph[0][curr[0]]\n            for i in range(len(curr)-1):\n                cost += graph[curr[i]][curr[i+1]]\n            min_cost = min(min_cost, cost)\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], vertices)\n    return min_cost"},
    {"complexity": "O(n!)", "name": "permute_string", "description": "Permutes a string", "code": "def permute_string(s):\n    result = []\n    def permute(curr, remaining):\n        if not remaining:\n            result.append(''.join(curr))\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], list(s))\n    return result"},
    {"complexity": "O(n!)", "name": "generate_perms_unique", "description": "Generates unique permutations", "code": "def generate_perms_unique(nums):\n    result = []\n    def permute(curr, remaining, seen):\n        if not remaining:\n            result.append(curr[:])\n        seen_prev = set()\n        for i in range(len(remaining)):\n            if remaining[i] not in seen_prev:\n                seen_prev.add(remaining[i])\n                permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:], seen)\n    nums.sort()\n    permute([], nums, set())\n    return result"},
    {"complexity": "O(n!)", "name": "solve_hamiltonian", "description": "Finds Hamiltonian cycle", "code": "def solve_hamiltonian(graph):\n    n = len(graph)\n    def is_valid(v, pos, path):\n        if graph[path[pos-1]][v] == 0 or v in path:\n            return False\n        return True\n    def hamiltonian_util(path, pos):\n        if pos == n and graph[path[pos-1]][path[0]]:\n            return True\n        for v in range(1, n):\n            if is_valid(v, pos, path):\n                path[pos] = v\n                if hamiltonian_util(path, pos+1):\n                    return True\n                path[pos] = -1\n        return False\n    path = [-1] * n\n    path[0] = 0\n    return hamiltonian_util(path, 1) and path"},
    {"complexity": "O(n!)", "name": "permute_with_sum", "description": "Permutes with sum constraint", "code": "def permute_with_sum(nums, target):\n    result = []\n    def permute(curr, remaining, curr_sum):\n        if curr_sum == target and not remaining:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:], curr_sum + remaining[i])\n    permute([], nums, 0)\n    return result"},
    {"complexity": "O(n!)", "name": "solve_graph_coloring", "description": "Solves graph coloring", "code": "def solve_graph_coloring(graph, m):\n    n = len(graph)\n    result = [-1] * n\n    def is_safe(v, c):\n        for i in range(n):\n            if graph[v][i] and result[i] == c:\n                return False\n        return True\n    def color_util(pos):\n        if pos == n:\n            return True\n        for c in range(1, m+1):\n            if is_safe(pos, c):\n                result[pos] = c\n                if color_util(pos+1):\n                    return True\n                result[pos] = -1\n        return False\n    return color_util(0) and result"},
    {"complexity": "O(n!)", "name": "permute_with_product", "description": "Permutes with product constraint", "code": "def permute_with_product(nums, target):\n    result = []\n    def permute(curr, remaining, prod):\n        if prod == target and not remaining:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:], prod * remaining[i])\n    permute([], nums, 1)\n    return result"},
    {"complexity": "O(n!)", "name": "solve_knapsack", "description": "Solves knapsack with brute force", "code": "def solve_knapsack(values, weights, W):\n    max_val = [0]\n    result = []\n    def knapsack(pos, curr, curr_w, curr_v):\n        nonlocal max_val\n        if curr_w <= W and curr_v > max_val[0]:\n            max_val[0] = curr_v\n            result[:] = curr[:]\n        if pos >= len(values):\n            return\n        for i in range(pos, len(values)):\n            knapsack(i+1, curr + [values[i]], curr_w + weights[i], curr_v + values[i])\n            knapsack(i+1, curr, curr_w, curr_v)\n    knapsack(0, [], 0, 0)\n    return result"},
    {"complexity": "O(n!)", "name": "permute_with_diff", "description": "Permutes with difference constraint", "code": "def permute_with_diff(nums, k):\n    result = []\n    def permute(curr, remaining):\n        if not remaining:\n            for i in range(len(curr)-1):\n                if abs(curr[i] - curr[i+1]) != k:\n                    return\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], nums)\n    return result"},
    {"complexity": "O(n!)", "name": "solve_tsp_all_paths", "description": "Finds all TSP paths", "code": "def solve_tsp_all_paths(graph):\n    n = len(graph)\n    vertices = [i for i in range(1, n)]\n    result = []\n    def permute(curr, remaining):\n        if not remaining:\n            cost = graph[curr[-1]][0] + [graph[0][curr[0]]]\n            for i in range(len(curr)-1):\n                cost += graph[curr[i]][curr[i+1]]]\n            result.append((curr[:], cost))\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], vertices)\n    return result"},
    {"complexity": "O(n!)", "name": "permute_with_max", "description": "Permutes with max constraint", "code": "def permute_with_max(nums, max_val):\n    result = []\n    def permute(curr, remaining):\n        if not remaining and max(curr) <= max_val:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], nums)\n    return result"},
    {"complexity": "O(n!)", "name": "solve_subset_perms", "description": "Generates perms of subsets", "code": "def solve_subset_perms(nums):\n    result = []\n    def permute(curr, remaining):\n        if curr:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n        permute([], nums)\n        return result"},
    {"complexity": "O(n!)", "name": "permute_with_sum_k", "description": "Permutes with sum k", "code": "def permute_with_sum_k(nums, k):\n    result = []\n    def permute(curr, remaining, curr_sum):\n        if curr_sum == k and not remaining:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:], curr_sum + remaining[i])\n    permute([], nums, 0)\n    return result"},
    {"complexity": "O(n!)", "name": "solve_permute_pairs", "description": "Generates permuted pairs", "code": "def solve_permute_pairs(nums):\n    result = []\n    def permute(curr, remaining):\n        if len(curr) == 2:\n            result.append(curr[:])\n        for i in range(len(remaining))):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], nums)\n    return result"},
    {"complexity": "O(n!)", "name": "permute_with_min", "description": "Permutes with min constraint", "code": "def permute_with_min(nums, min_val):\n    result = []\n    def permute(curr, remaining):\n        if not remaining and min(curr) >= min_val:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], nums)\n    return result"},
    {"complexity": "O(n!)", "name": "solve_permute_triplets", "description": "Generates permuted triplets", "code": "def solve_permute_triplets(nums):\n    result = []\n    def permute(curr, remaining):\n        if len(curr) == 3:\n            result.append(curr[:])\n        for i in range(len(remaining)):\n            permute(curr + [remaining[i]], remaining[:i] + remaining[i+1:])\n    permute([], nums)\n    return result"}
]