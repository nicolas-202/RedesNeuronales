[

  {"code": "def return_constant(): return 42", "label": "O(1)"},
  {"code": "def get_first(lst): return lst[0]", "label": "O(1)"},
  {"code": "def access_dict(d, key): return d[key]", "label": "O(1)"},
  {"code": "def check_even(n): return n % 2 == 0", "label": "O(1)"},
  {"code": "def always_false(): return False", "label": "O(1)"},
  {"code": "def assign_x(x): y = x; return y", "label": "O(1)"},
  {"code": "def set_item(lst, idx, val): lst[idx] = val; return lst", "label": "O(1)"},
  {"code": "def pop_stack(stack): return stack.pop()", "label": "O(1)"},
  {"code": "def mul(a, b): return a * b", "label": "O(1)"},
  {"code": "def get_last_char(s): return s[-1]", "label": "O(1)"},
  {"code": "def is_none(v): return v is None", "label": "O(1)"},
  {"code": "def get_tuple(t): return t[1]", "label": "O(1)"},
  {"code": "def add_one(x): return x + 1", "label": "O(1)"},
  {"code": "def get_len_abc(): return len('abc')", "label": "O(1)"},
  {"code": "def is_upper(c): return c.isupper()", "label": "O(1)"},
  {"code": "def negate(b): return not b", "label": "O(1)"},
  {"code": "def always_true(): return True", "label": "O(1)"},
  {"code": "def return_none(): return None", "label": "O(1)"},
  {"code": "def minmax(): return min(1,2), max(1,2)", "label": "O(1)"},
  {"code": "def get_ascii(c): return ord(c)", "label": "O(1)"},


  {"code": "def binary_search(a, x): l, r = 0, len(a)-1; while l <= r: m = (l + r) // 2; if a[m] == x: return m; elif a[m] < x: l = m + 1; else: r = m - 1; return -1", "label": "O(log n)"},
  {"code": "def log_steps(n): steps = 0; while n > 1: n //= 2; steps += 1; return steps", "label": "O(log n)"},
  {"code": "def count_halves(n): c = 0; while n > 0: n //= 2; c += 1; return c", "label": "O(log n)"},
  {"code": "def leftmost_bs(arr, x): l, r = 0, len(arr)-1; res = -1; while l <= r: m = (l+r)//2; if arr[m]==x: res=m; r=m-1; elif arr[m]<x: l=m+1; else: r=m-1; return res", "label": "O(log n)"},
  {"code": "def num_bits(n): return n.bit_length()", "label": "O(log n)"},
  {"code": "def find_peak(arr): l, r = 0, len(arr)-1; while l<r: m=(l+r)//2; if arr[m]<arr[m+1]: l=m+1; else: r=m; return l", "label": "O(log n)"},
  {"code": "def fast_exp(x, n): res=1; while n: res*=x if n%2 else 1; x*=x; n//=2; return res", "label": "O(log n)"},
  {"code": "def log_base_k(n,k): c=0; while n>=k: n//=k; c+=1; return c", "label": "O(log n)"},
  {"code": "def find_power2(n): p=1; while p*2<=n: p*=2; return p", "label": "O(log n)"},
  {"code": "def ceil_log2(n): i=0; while 1<<i<n: i+=1; return i", "label": "O(log n)"},
  {"code": "def rightmost_bs(arr, x): l, r = 0, len(arr)-1; res=-1; while l<=r: m=(l+r)//2; if arr[m]==x: res=m; l=m+1; elif arr[m]<x: l=m+1; else: r=m-1; return res", "label": "O(log n)"},
  {"code": "def binary_find(arr, f): l, r = 0, len(arr)-1; while l<=r: m=(l+r)//2; if f(arr[m]): return m; elif arr[m]<arr[r]: l=m+1; else: r=m-1; return -1", "label": "O(log n)"},
  {"code": "def log3_count(n): cnt=0; while n>=3: n//=3; cnt+=1; return cnt", "label": "O(log n)"},
  {"code": "def min_rotated(arr): l,r=0,len(arr)-1; while l<r: m=(l+r)//2; if arr[m]>arr[r]: l=m+1; else: r=m; return arr[l]", "label": "O(log n)"},
  {"code": "def find_smallest_gt(arr, x): l,r=0,len(arr)-1; ans=-1; while l<=r: m=(l+r)//2; if arr[m]>x: ans=m; r=m-1; else: l=m+1; return ans", "label": "O(log n)"},
  {"code": "def kth_bit(n,k): return (n>>k)&1", "label": "O(log n)"},
  {"code": "def find_largest_lt(arr, x): l,r=0,len(arr)-1; ans=-1; while l<=r: m=(l+r)//2; if arr[m]<x: ans=m; l=m+1; else: r=m-1; return ans", "label": "O(log n)"},
  {"code": "def log_div(n): count=0; while n>1: n//=5; count+=1; return count", "label": "O(log n)"},
  {"code": "def upper_bound(arr,x): l,r=0,len(arr); while l<r: m=(l+r)//2; if arr[m]<=x: l=m+1; else: r=m; return l", "label": "O(log n)"},
  {"code": "def insert_bs(arr,x): l,r=0,len(arr); while l<r: m=(l+r)//2; if arr[m]<x: l=m+1; else: r=m; return l", "label": "O(log n)"},


  {"code": "def sum_list(lst): total=0; for x in lst: total+=x; return total", "label": "O(n)"},
  {"code": "def find_min(lst): m=lst[0]; for x in lst: m=min(m,x); return m", "label": "O(n)"},
  {"code": "def count_zeros(lst): return sum(1 for x in lst if x==0)", "label": "O(n)"},
  {"code": "def double_values(lst): return [2*x for x in lst]", "label": "O(n)"},
  {"code": "def all_even(lst): return all(x%2==0 for x in lst)", "label": "O(n)"},
  {"code": "def count_positive(lst): return sum(1 for x in lst if x>0)", "label": "O(n)"},
  {"code": "def reverse_list(lst): return lst[::-1]", "label": "O(n)"},
  {"code": "def find_index(lst, k): for i,x in enumerate(lst): if x==k: return i; return -1", "label": "O(n)"},
  {"code": "def copy_dict(d): return {k:v for k,v in d.items()}", "label": "O(n)"},
  {"code": "def count_char(s): return len([c for c in s])", "label": "O(n)"},
  {"code": "def is_sorted(lst): for i in range(len(lst)-1): if lst[i]>lst[i+1]: return False; return True", "label": "O(n)"},
  {"code": "def find_first_pos(lst): for x in lst: if x>0: return x; return None", "label": "O(n)"},
  {"code": "def capitalize_words(s): return ' '.join(w.capitalize() for w in s.split())", "label": "O(n)"},
  {"code": "def count_spaces(s): return s.count(' ')", "label": "O(n)"},
  {"code": "def flatten(lst): return [item for sub in lst for item in sub]", "label": "O(n)"},
  {"code": "def product_list(lst): prod=1; for x in lst: prod*=x; return prod", "label": "O(n)"},
  {"code": "def running_sum(lst): out=[]; s=0; for x in lst: s+=x; out.append(s); return out", "label": "O(n)"},
  {"code": "def prefix_sum(lst): res=[0]*len(lst); total=0; for i,v in enumerate(lst): total+=v; res[i]=total; return res", "label": "O(n)"},
  {"code": "def average(lst): return sum(lst)/len(lst)", "label": "O(n)"},
  {"code": "def count_vowels(s): return sum(1 for c in s if c in 'aeiouAEIOU')", "label": "O(n)"},


  {"code": "def merge_sort(arr): if len(arr)>1: mid=len(arr)//2; L=arr[:mid]; R=arr[mid:]; merge_sort(L); merge_sort(R); i=j=k=0; while i<len(L) and j<len(R): arr[k]=L[i] if L[i]<R[j] else R[j]; i+=L[i]<R[j]; j+=L[i]>=R[j]; k+=1; while i<len(L): arr[k]=L[i]; i+=1; k+=1; while j<len(R): arr[k]=R[j]; j+=1; k+=1", "label": "O(n log n)"},
  {"code": "def quicksort(arr): if len(arr)<=1: return arr; p=arr[len(arr)//2]; left=[x for x in arr if x<p]; mid=[x for x in arr if x==p]; right=[x for x in arr if x>p]; return quicksort(left)+mid+quicksort(right)", "label": "O(n log n)"},
  {"code": "def heap_sort(arr): import heapq; heapq.heapify(arr); return [heapq.heappop(arr) for _ in range(len(arr))]", "label": "O(n log n)"},
  {"code": "def sort_by_length(lst): return sorted(lst, key=len)", "label": "O(n log n)"},
  {"code": "def unique_sorted(lst): return sorted(set(lst))", "label": "O(n log n)"},
  {"code": "def merge_lists(a,b): return sorted(a+b)", "label": "O(n log n)"},
  {"code": "def sort_indices(arr): return sorted(range(len(arr)), key=lambda i: arr[i])", "label": "O(n log n)"},
  {"code": "def tim_sort(arr): return sorted(arr)", "label": "O(n log n)"},
  {"code": "def stable_sort(lst): return sorted(lst, key=lambda x:(x[1],x[0]))", "label": "O(n log n)"},
  {"code": "def sort_case_insensitive(lst): return sorted(lst, key=lambda x: x.lower())", "label": "O(n log n)"},
  {"code": "def merge_sort_rev(lst): if len(lst)>1: mid=len(lst)//2; L=lst[:mid]; R=lst[mid:]; merge_sort_rev(L); merge_sort_rev(R); i=j=k=0; while i<len(L) and j<len(R): lst[k]=L[i] if L[i]>R[j] else R[j]; i+=L[i]>R[j]; j+=L[i]<=R[j]; k+=1; while i<len(L): lst[k]=L[i]; i+=1; k+=1; while j<len(R): lst[k]=R[j]; j+=1; k+=1", "label": "O(n log n)"},
  {"code": "def sort_by_abs(lst): return sorted(lst, key=abs)", "label": "O(n log n)"},
  {"code": "def sort_tuple_by_second(tpls): return sorted(tpls, key=lambda x: x[1])", "label": "O(n log n)"},
  {"code": "def sort_by_mod(lst): return sorted(lst, key=lambda x: x%3)", "label": "O(n log n)"},
  {"code": "def sort_dict_by_value(d): return sorted(d.items(), key=lambda x: x[1])", "label": "O(n log n)"},
  {"code": "def sort_and_remove_dups(lst): return sorted(set(lst))", "label": "O(n log n)"},
  {"code": "def sort_words_by_length(words): return sorted(words, key=len)", "label": "O(n log n)"},
  {"code": "def sort_by_custom(lst): return sorted(lst, key=lambda x: (x.count('a'), len(x)))", "label": "O(n log n)"},
  {"code": "def sort_numbers_desc(lst): return sorted(lst, reverse=True)", "label": "O(n log n)"},
  {"code": "def merge_sorted_arrays(a,b): i=j=0; res=[]; while i<len(a) and j<len(b): res.append(a[i] if a[i]<b[j] else b[j]); i+=a[i]<b[j]; j+=a[i]>=b[j]; res.extend(a[i:]); res.extend(b[j:]); return res", "label": "O(n log n)"},


  {"code": "def duplicates_brute(lst): for i in range(len(lst)): for j in range(i+1,len(lst)): if lst[i]==lst[j]: return True; return False", "label": "O(n^2)"},
  {"code": "def matrix_add(A,B): n=len(A); C=[[0]*n for _ in range(n)]; for i in range(n): for j in range(n): C[i][j]=A[i][j]+B[i][j]; return C", "label": "O(n^2)"},
  {"code": "def bubble_sort(arr): n=len(arr); for i in range(n): for j in range(0,n-i-1): if arr[j]>arr[j+1]: arr[j],arr[j+1]=arr[j+1],arr[j]", "label": "O(n^2)"},
  {"code": "def all_pairs(lst): pairs=[]; for i in lst: for j in lst: pairs.append((i,j)); return pairs", "label": "O(n^2)"},
  {"code": "def count_inversions(arr): c=0; for i in range(len(arr)): for j in range(i+1,len(arr)): if arr[i]>arr[j]: c+=1; return c", "label": "O(n^2)"},
  {"code": "def all_substrings(s): res=[]; n=len(s); for i in range(n): for j in range(i+1,n+1): res.append(s[i:j]); return res", "label": "O(n^2)"},
  {"code": "def insertion_sort(arr): for i in range(1,len(arr)): key=arr[i]; j=i-1; while j>=0 and arr[j]>key: arr[j+1]=arr[j]; j-=1; arr[j+1]=key", "label": "O(n^2)"},
  {"code": "def selection_sort(arr): n=len(arr); for i in range(n): min_idx=i; for j in range(i+1,n): if arr[j]<arr[min_idx]: min_idx=j; arr[i],arr[min_idx]=arr[min_idx],arr[i]", "label": "O(n^2)"},
  {"code": "def transpose(m): n=len(m); t=[[0]*n for _ in range(n)]; for i in range(n): for j in range(n): t[j][i]=m[i][j]; return t", "label": "O(n^2)"},
  {"code": "def find_zero_sum_pairs(lst): res=[]; for i in range(len(lst)): for j in range(i+1,len(lst)): if lst[i]+lst[j]==0: res.append((lst[i],lst[j])); return res", "label": "O(n^2)"},
  {"code": "def lower_triangular(m): n=len(m); for i in range(n): for j in range(i): m[i][j]=0; return m", "label": "O(n^2)"},
  {"code": "def upper_triangular(m): n=len(m); for i in range(n): for j in range(i+1,n): m[i][j]=0; return m", "label": "O(n^2)"},
  {"code": "def palindrome_substrings(s): n=len(s); palins=[]; for i in range(n): for j in range(i,n): if s[i:j+1]==s[i:j+1][::-1]: palins.append(s[i:j+1]); return palins", "label": "O(n^2)"},
  {"code": "def all_pairs_sum(lst): sums=[]; for i in lst: for j in lst: sums.append(i+j); return sums", "label": "O(n^2)"},
  {"code": "def count_duplicate_pairs(lst): c=0; for i in range(len(lst)): for j in range(i+1,len(lst)): if lst[i]==lst[j]: c+=1; return c", "label": "O(n^2)"},
  {"code": "def all_subarrays(lst): n=len(lst); out=[]; for i in range(n): for j in range(i,n): out.append(lst[i:j+1]); return out", "label": "O(n^2)"},
  {"code": "def brute_majority(lst): for i in lst: c=0; for j in lst: c+=i==j; if c>len(lst)//2: return i; return None", "label": "O(n^2)"},
  {"code": "def brute_intersection(a,b): res=[]; for i in a: for j in b: if i==j: res.append(i); return res", "label": "O(n^2)"},
  {"code": "def brute_anagram(a,b): if len(a)!=len(b): return False; for i in a: if a.count(i)!=b.count(i): return False; return True", "label": "O(n^2)"},
  {"code": "def diagonal_sum(m): n=len(m); s=0; for i in range(n): for j in range(n): if i==j: s+=m[i][j]; return s", "label": "O(n^2)"},

  {"code": "def triple_sum_zero(nums): n=len(nums); triplets=[]; for i in range(n): for j in range(i+1,n): for k in range(j+1,n): if nums[i]+nums[j]+nums[k]==0: triplets.append((nums[i],nums[j],nums[k])); return triplets", "label": "O(n^3)"},
  {"code": "def cube_matrix(m): n=len(m); r=[[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]; for i in range(n): for j in range(n): for k in range(n): r[i][j][k]=m[i][j]*m[j][k]*m[k][i]; return r", "label": "O(n^3)"},
  {"code": "def triple_nested(lst): c=0; for a in lst: for b in lst: for c2 in lst: c+=a+b+c2; return c", "label": "O(n^3)"},
  {"code": "def all_triplets(lst): r=[]; for i in lst: for j in lst: for k in lst: r.append((i,j,k)); return r", "label": "O(n^3)"},
  {"code": "def count_equal_triplets(lst): c=0; for i in range(len(lst)): for j in range(len(lst)): for k in range(len(lst)): c+=lst[i]==lst[j]==lst[k]; return c", "label": "O(n^3)"},
  {"code": "def all_triplet_products(nums): n=len(nums); prods=[]; for i in range(n): for j in range(n): for k in range(n): prods.append(nums[i]*nums[j]*nums[k]); return prods", "label": "O(n^3)"},
  {"code": "def triplet_indices_sum(n): t=0; for i in range(n): for j in range(n): for k in range(n): t+=i+j+k; return t", "label": "O(n^3)"},
  {"code": "def symmetric_3d_matrix(M): n=len(M); for i in range(n): for j in range(n): for k in range(n): if M[i][j][k]!=M[k][j][i]: return False; return True", "label": "O(n^3)"},
  {"code": "def count_triplets(lst): c=0; for i in range(len(lst)): for j in range(i+1,len(lst)): for k in range(j+1,len(lst)): c+=1; return c", "label": "O(n^3)"},
  {"code": "def triple_nested_sum(n): t=0; for i in range(n): for j in range(n): for k in range(n): t+=i+j+k; return t", "label": "O(n^3)"},
  {"code": "def triple_matrix_sum(A,B,C): n=len(A); D=[[0]*n for _ in range(n)]; for i in range(n): for j in range(n): for k in range(n): D[i][j]+=A[i][k]+B[k][j]+C[j][i]; return D", "label": "O(n^3)"},
  {"code": "def count_palindromic_triplets(s): n=len(s); c=0; for i in range(n): for j in range(i,n): for k in range(j,n): c+=s[i:k+1]==s[i:k+1][::-1]; return c", "label": "O(n^3)"},
  {"code": "def triple_loop(lst): res=0; for i in lst: for j in lst: for k in lst: res+=i*j*k; return res", "label": "O(n^3)"},
  {"code": "def count_distinct_triplets(lst): c=0; for i in lst: for j in lst: for k in lst: c+=len({i,j,k})==3; return c", "label": "O(n^3)"},
  {"code": "def cube_sum(lst): t=0; for i in lst: for j in lst: for k in lst: t+=i+j+k; return t", "label": "O(n^3)"},
  {"code": "def all_triplet_sums(lst): s=[]; for i in lst: for j in lst: for k in lst: s.append(i+j+k); return s", "label": "O(n^3)"},
  {"code": "def count_triplets_multiple(lst): c=0; for i in lst: for j in lst: for k in lst: c+=i*j==k; return c", "label": "O(n^3)"},
  {"code": "def triple_compare(lst): for i in lst: for j in lst: for k in lst: pass", "label": "O(n^3)"},
  {"code": "def find_triplets(lst): n=len(lst); for i in range(n): for j in range(i+1,n): for k in range(j+1,n): if lst[i]<lst[j]<lst[k]: return True; return False", "label": "O(n^3)"},
  {"code": "def brute_force_triangle(a): n=len(a); c=0; for i in range(n): for j in range(i+1,n): for k in range(j+1,n): c+=a[i]+a[j]>a[k] and a[i]+a[k]>a[j] and a[j]+a[k]>a[i]; return c", "label": "O(n^3)"},


  {"code": "def fibonacci(n): return n if n<=1 else fibonacci(n-1)+fibonacci(n-2)", "label": "O(2^n)"},
  {"code": "def subsets(nums): res=[]; def backtrack(path,idx): res.append(list(path)); [path.append(nums[i]) or backtrack(path,i+1) or path.pop() for i in range(idx,len(nums))]; backtrack([],0); return res", "label": "O(2^n)"},
  {"code": "def hanoi(n): return 1 if n==1 else 2*hanoi(n-1)+1", "label": "O(2^n)"},
  {"code": "def power_set(s): res=[[]]; [res.extend([x+[e] for x in res]) for e in s]; return res", "label": "O(2^n)"},
  {"code": "def count_subsets(nums): return 1 if not nums else count_subsets(nums[1:])+count_subsets(nums[1:])", "label": "O(2^n)"},
  {"code": "def can_sum(nums, target): return target==0 or (nums and (can_sum(nums[1:],target) or can_sum(nums[1:],target-nums[0])))", "label": "O(2^n)"},
  {"code": "def all_combinations(s): return [''] if not s else all_combinations(s[1:]) + [s[0]+comb for comb in all_combinations(s[1:])]", "label": "O(2^n)"},
  {"code": "def string_partitions(s): return [[]] if not s else [[s[:i]]+part for i in range(1,len(s)+1) for part in string_partitions(s[i:])]", "label": "O(2^n)"},
  {"code": "def all_parentheses(n,s='',l=0,r=0): return [s] if len(s)==2*n else (all_parentheses(n,s+'(',l+1,r) if l<n else [])+(all_parentheses(n,s+')',l,r+1) if r<l else [])", "label": "O(2^n)"},
  {"code": "def count_ways(n): return 1 if n==0 else count_ways(n-1)+count_ways(n-2) if n>1 else count_ways(n-1)", "label": "O(2^n)"},
  {"code": "def generate_subsets(nums): return [[]] if not nums else generate_subsets(nums[1:])+[[nums[0]]+x for x in generate_subsets(nums[1:])]", "label": "O(2^n)"},
  {"code": "def coin_change(coins, amount): return 1 if amount==0 else 0 if amount<0 or not coins else coin_change(coins,amount-coins[0])+coin_change(coins[1:],amount)", "label": "O(2^n)"},
  {"code": "def min_sum(nums,target): return 0 if target==0 else float('inf') if target<0 else min([1+min_sum(nums,target-n) for n in nums])", "label": "O(2^n)"},
  {"code": "def count_decodings(s): return 1 if not s else (count_decodings(s[1:]) if s[0]!='0' else 0)+(count_decodings(s[2:]) if len(s)>1 and 10<=int(s[:2])<=26 else 0)", "label": "O(2^n)"},
  {"code": "def all_paths(m,n): return 1 if m==1 or n==1 else all_paths(m-1,n)+all_paths(m,n-1)", "label": "O(2^n)"},
  {"code": "def recursive_partition(n): return 1 if n==0 else sum(recursive_partition(n-i) for i in range(1,n+1))", "label": "O(2^n)"},
  {"code": "def jump_ways(n): return 1 if n==0 else 0 if n<0 else jump_ways(n-1)+jump_ways(n-2)", "label": "O(2^n)"},
  {"code": "def split_array(arr): return [[]] if not arr else split_array(arr[1:])+[[arr[0]]+x for x in split_array(arr[1:])]", "label": "O(2^n)"},
  {"code": "def unique_subsets(lst): return [[]] if not lst else unique_subsets(lst[1:])+[[lst[0]]+x for x in unique_subsets(lst[1:])]", "label": "O(2^n)"},
  {"code": "def all_possible_sums(arr): return [0] if not arr else all_possible_sums(arr[1:])+[arr[0]+x for x in all_possible_sums(arr[1:])]", "label": "O(2^n)"},


  {"code": "def permutations(lst): return [[]] if not lst else [[lst[i]]+p for i in range(len(lst)) for p in permutations(lst[:i]+lst[i+1:])]", "label": "O(n!)"},
  {"code": "def unique_permutations(nums): res=[]; def backtrack(path,used): res.append(list(path)) if len(path)==len(nums) else [used.__setitem__(i,True) or path.append(nums[i]) or backtrack(path,used) or path.pop() or used.__setitem__(i,False) for i in range(len(nums)) if not used[i]]; backtrack([], [False]*len(nums)); return res", "label": "O(n!)"},
  {"code": "def all_arrangements(s): return [s] if len(s)<=1 else [c+perm for i,c in enumerate(s) for perm in all_arrangements(s[:i]+s[i+1:])]", "label": "O(n!)"},
  {"code": "from itertools import permutations\ndef permute(l): return list(permutations(l))", "label": "O(n!)"},
  {"code": "def permute_colors(colors): return [ [colors[i]]+p for i in range(len(colors)) for p in permute_colors(colors[:i]+colors[i+1:]) ] if colors else [[]]", "label": "O(n!)"},
  {"code": "def all_seatings(people): return [[]] if not people else [[people[i]]+p for i in range(len(people)) for p in all_seatings(people[:i]+people[i+1:])]", "label": "O(n!)"},
  {"code": "def string_permutations(s): return [''] if len(s)==0 else [s[i]+perm for i in range(len(s)) for perm in string_permutations(s[:i]+s[i+1:])]", "label": "O(n!)"},
  {"code": "def get_anagrams(word): return [word] if len(word)<=1 else [c+sub for i,c in enumerate(word) for sub in get_anagrams(word[:i]+word[i+1:])]", "label": "O(n!)"},
  {"code": "def all_permutation_tuples(t): return [()] if len(t)==0 else [(t[i],)+p for i in range(len(t)) for p in all_permutation_tuples(t[:i]+t[i+1:])]", "label": "O(n!)"},
  {"code": "def permutation_sum(nums): from itertools import permutations; return sum(sum(p) for p in permutations(nums))", "label": "O(n!)"},
  {"code": "def permute_and_combine(lst): from itertools import permutations; return [''.join(map(str,p)) for p in permutations(lst)]", "label": "O(n!)"},
  {"code": "def all_digit_permutations(digits): return [[]] if not digits else [[digits[i]]+p for i in range(len(digits)) for p in all_digit_permutations(digits[:i]+digits[i+1:])]", "label": "O(n!)"},
  {"code": "def all_permuted_strings(s): return [''] if len(s)==0 else [s[i]+perm for i in range(len(s)) for perm in all_permuted_strings(s[:i]+s[i+1:])]", "label": "O(n!)"},
  {"code": "def all_permutations_with_prefix(prefix,lst): return [prefix] if not lst else [x for i in range(len(lst)) for x in all_permutations_with_prefix(prefix+[lst[i]],lst[:i]+lst[i+1:])]", "label": "O(n!)"},
  {"code": "def all_unique_permutations(arr): from itertools import permutations; return set(permutations(arr))", "label": "O(n!)"},
  {"code": "def permute_subset(arr): return [arr] if len(arr)<=1 else [ [arr[i]]+p for i in range(len(arr)) for p in permute_subset(arr[:i]+arr[i+1:]) ]", "label": "O(n!)"},
  {"code": "def generate_all_perms(arr): return [arr] if len(arr)<=1 else [ [arr[i]]+p for i in range(len(arr)) for p in generate_all_perms(arr[:i]+arr[i+1:]) ]", "label": "O(n!)"},
  {"code": "def all_orders(arr): return [arr] if len(arr)<=1 else [ [arr[i]]+p for i in range(len(arr)) for p in all_orders(arr[:i]+arr[i+1:]) ]", "label": "O(n!)"},
  {"code": "def permute_with_index(arr): return [arr] if len(arr)<=1 else [ [arr[i]]+p for i in range(len(arr)) for p in permute_with_index(arr[:i]+arr[i+1:]) ]", "label": "O(n!)"},
  {"code": "def permute_array(arr): return [arr] if len(arr)<=1 else [ [arr[i]]+p for i in range(len(arr)) for p in permute_array(arr[:i]+arr[i+1:]) ]", "label": "O(n!)"}
]